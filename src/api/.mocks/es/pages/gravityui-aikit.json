{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:57:57.515Z",
  "updatedAt": "2026-01-27T13:57:57.515Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "en",
  "publishedVersionId": 268,
  "lastVersionId": 268,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **Ilia Lomtev**\n\n          Desarrollador frontend\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          En este artículo:\n\n            - [Cómo y por qué creamos AIKit](#why)\n            - [Arquitectura de AIKit: en qué nos basamos](#architecture)\n            - [Cómo crear tu propio chat](#how)\n            - [Cómo AIKit influyó en los servicios](#influence)\n            - [Qué sigue](#further)\n            - [Cómo probar AIKit](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nDurante el último año hemos visto un boom de asistentes de IA, y esto también ha llegado a las interfaces de Yandex\\_Cloud: a veces aparece un chatbot con un modelo en el soporte técnico, y otras — en la consola — un agente para operaciones de trabajo. Los equipos conectaban modelos, diseñaban la lógica conversacional, dibujaban el diseño y montaban chats — y lo hacían todo por separado.\\n\\nDistintos equipos construían interfaces sobre el framework común Gravity UI, pero poco a poco surgieron tantas variaciones que se volvió difícil mantener una experiencia de usuario unificada. Y además, los compañeros cada vez se encontraban más con que perdían tiempo resolviendo una y otra vez lo mismo.\\n\\nPara dejar de reinventar la rueda cada vez, reunimos las prácticas acumuladas en un enfoque único e hicimos una herramienta para chatbots con IA — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}. Permite crear una interfaz completa de asistente en pocos días y, al mismo tiempo, adaptarla fácilmente a distintos escenarios.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nMe llamo Ilia Lomtev, soy desarrollador senior en el equipo Foundation Services de Yandex\\_Cloud, y en este artículo contaré por qué decidimos crear AIKit, cómo está organizado, un poco sobre los planes a futuro — y sobre lo que podéis probar por vuestra cuenta.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Cómo y por qué creamos AIKit{#why}\\n\\nDurante el último año, en Yandex\\_Cloud creció el número de servicios con asistentes de IA, por ejemplo: \\n\\n  * Code Assistant Chat en SourceCraft — el asistente ayuda a los desarrolladores a escribir código y, en modo de agente de IA, crea y configura repositorios, lanza procesos CI/CD, responde preguntas sobre la documentación y automatiza tareas. También sabe gestionar issues y pull requests, y trabajar con el código: explicar, crear y editar archivos.\\n\\n  * Asistente de IA en la consola de la nube — un asistente diseñado para gestionar recursos en Yandex\\_Cloud. La tarea principal es ayudar a configurar, modificar y administrar la infraestructura cloud de forma rápida y segura, ocultando la complejidad de la interacción con la API y las herramientas.\\n\\nEn el ecosistema aparecieron una decena de chats, cada uno con su propia lógica, su formato de mensajes y su conjunto de casos borde. \\n\\nDescubrimos que los equipos llegan a un conjunto de tareas más o menos similar. Lo que la mayoría necesita: \\n\\n  * mostrar con cuidado los mensajes del usuario y del asistente, \\n\\n  * organizar correctamente el streaming de respuestas, \\n\\n  * mostrar el indicador «el asistente está escribiendo», \\n\\n  * manejar errores como una conexión cortada o reintentos. \\n\\nLas tareas son esencialmente las mismas, pero hay muchas formas de resolverlas, y el UX difiere. Por ejemplo, la ubicación y la forma de mostrar el historial de chats: puede ser una pantalla aparte que se abre como un menú, o una lista de chats en un popup.\\n\\nSe manifestó un problema: la experiencia entre distintos chats difería de manera significativa. En algunos lugares el asistente hacía streaming de la respuesta, y en otros mostraba de inmediato el texto ya listo. En una interfaz los mensajes se agrupaban, y en otra iban en una cinta continua. Esto rompía el UX común: el usuario pasa de un producto a otro dentro del mismo ecosistema, pero las sensaciones con el asistente son completamente distintas.   \\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: Ejemplos de chats construidos con AIKit, en tema claro\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Además, se hizo evidente que desplegar nuevas funcionalidades en los\n          modelos se volvía cada vez más difícil. Para comunicar a los usuarios,\n          por ejemplo, capacidades de herramientas, multimodalidad o respuestas\n          estructuradas de las tools, había que acordar el contrato, mejorar los\n          backends y luego actualizar el UI en cada equipo por separado. En esas\n          condiciones, cualquier cambio llevaba mucho tiempo y escalaba mal.\n\n\n          Queríamos frenar este crecimiento de variabilidad y recuperar la\n          previsibilidad. Para ello, era necesario unificar el modelo de datos y\n          los patrones de trabajo, ofrecer componentes y hooks listos para usar\n          para que los equipos no tuvieran que empezar desde cero, y dejar\n          espacio para la personalización — porque los escenarios de cada uno\n          son diferentes. \n\n\n          Así llegamos a la idea de una biblioteca separada @gravity‑ui/aikit —\n          una extensión de Gravity UI que sigue los mismos principios, pero está\n          orientada a escenarios modernos de IA: diálogos, asistentes,\n          multimodalidad.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Arquitectura de AIKit: en qué nos basamos{#architecture}\\n\\nAl diseñar AIKkit, nos orientamos por la experiencia de [AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"} y varios principios fundamentales.\\n\\n**Atomic Design como base**: toda la biblioteca se construye desde átomos hasta páginas. Esta estructura aporta una jerarquía clara, permite reutilizar componentes y, si es necesario, cambiar el comportamiento en cualquier nivel.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**Totalmente agnóstico al SDK**: AIKit no depende de un proveedor de IA concreto. Se puede usar OpenAI, Alice\\_AI LLM o tu propio backend — el UI recibe los datos mediante props, y el estado y las peticiones se quedan del lado del producto. \\n\\n**Dos niveles de uso para escenarios complejos**: hay un componente listo que funciona «out of the box», y hay un hook con lógica que permite controlar completamente el UI. Por ejemplo, se puede usar `PromptInput` o construir tu propio campo de entrada sobre `usePromptInput`. Esto da flexibilidad sin necesidad de reescribir los cimientos.\\n\\n**Sistema de tipos extensible**. Para garantizar uniformidad y seguridad de tipos, reunimos un modelo de datos extensible. Los mensajes se representan con una estructura tipada única: hay mensajes del usuario, mensajes del asistente y varios tipos básicos de contenido — texto (`text`), razonamientos del modelo (`thinking`), herramientas (`tool`). Al mismo tiempo, se pueden añadir tipos propios mediante `MessageRendererRegistry`. \\n\\nTodo está tipado en TypeScript, lo que ayuda a construir escenarios complejos más rápido y evitar errores en la fase de desarrollo.\\n\\n```javascript\\n// 1. Definimos el tipo de datos\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. Creamos el componente de renderizado\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>Visualización del gráfico: {part.data.chartType}</div>;\\n};\\n// 3. Registramos el renderer\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. Lo usamos en AssistantMessage\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\nPor último, contemplamos tematización mediante variables CSS, añadimos i18n (RU/EN), garantizamos accesibilidad (ARIA, navegación por teclado) y configuramos pruebas de regresión visual con Playwright Component Testing en Docker — y la biblioteca quedó lista para uso en producción.\\n\\n### Qué hay bajo el capó \\n\\nEn la base de AIKit hay un modelo de diálogo unificado. Para crearlo, primero hubo que entender la jerarquía de los mensajes. \\n\\nLos mensajes son entidades bastante poliédricas. Existe el primer mensaje del LLM — es un stream. Pero dentro de él puede haber muchos mensajes anidados diferentes: en esencia son razonamientos, propuestas, llamadas a tools para resolver una pregunta. Todos esos submensajes diferentes son, de hecho, un solo mensaje del backend. Pero también cada uno de ellos puede perfectamente ser un mensaje separado en un uso simple de un LLM. \\n\\nPor eso dejamos la posibilidad de usar el chat de ambas maneras: los mensajes pueden estar anidados unos dentro de otros, o pueden ser planos — aquí todo depende de la necesidad.\\n\\nLa gestión de estado, al mismo tiempo, se queda del lado del servicio. AIKit no almacena los datos por sí mismo — los recibe desde fuera. Los equipos pueden usar React State, Redux, Zustand, Reatom — lo que sea conveniente. Nosotros solo damos hooks que encapsulan la lógica típica de UI, por ejemplo: \\n\\n  * scroll inteligente con `useSmartScroll`;\\n\\n  * trabajo con fechas, por ejemplo, formateo de fechas teniendo en cuenta la locale con `useDateFormatter`; \\n\\n  * manejo de mensajes de tools con `useToolMessage`;\\n\\n  * y todo lo demás que se necesita para construir un diálogo.\\n\\nAdemás de esto, AIKit sigue siendo extensible. Se pueden conectar cualquier modelo, crear tipos de contenido propios y construir el UI totalmente a medida — usando la lógica de los hooks o utilizando componentes listos como base. La arquitectura permite experimentar sin romper los principios comunes.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Cómo crear tu propio chat{#how}\n\n\n          Para crear nuestro primer chat, usaremos el componente preparado\n          ChatContainer:\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // Your message sending logic\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // Update state\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'Start a conversation by typing a message or selecting a suggestion.',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: 'Try asking:',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: 'Explain quantum computing in simple terms'\n                  },\n                  {\n                    id: '2',\n                    title: 'Write a poem about nature'\n                  },\n                  {\n                    id: '3',\n                    title: 'Help me debug my JavaScript code'\n                  },\n                  {\n                    id: '4',\n                    title: 'Summarize recent AI developments'\n                  }\n                ],\n                title: 'Welcome to AI Chat'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          «Out of the box» todo se ve así:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Añadamos un poco de ambiente festivo: \n\n\n          1. Ajustemos el estado inicial. \n\n              Para una configuración más fina, montaremos el chat a partir de componentes separados: `Header`, `MessageList`, `PromptBox`.\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AI Assistant\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"Pregunta lo que sea...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. Usemos distintos tipos de mensajes integrados, importados mediante\n          `MessageType`.\n\n              * `thinking` — mostrará el proceso de razonamiento de la IA (así el usuario puede estudiar la lógica con la que el asistente prepara la respuesta).\n\n              * `tool` — sirve para mostrar bloques interactivos de la respuesta; en nuestro caso, es un bloque con código, donde el resaltado de sintaxis funciona correctamente y se soportan operaciones de edición y copia al portapapeles.\n\n              También se pueden añadir tipos propios, por ejemplo, mensajes con imágenes:\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. Añadamos estilización mediante CSS…\n\n              …y obtendremos un chat con Ded Moroz:)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          Para una personalización completa de elementos individuales se pueden\n          usar hooks — ¡nos encantará ver vuestras variantes de estilo en los\n          comentarios bajo el artículo!\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Cómo AIKit influyó en los servicios{#influence}\\n\\nEl resultado del uso de AIKit en Yandex\\_Cloud se notó rápidamente. En todos los servicios, los asistentes empezaron a comportarse igual: hacer streaming de respuestas de la misma manera, mostrar errores de la misma manera, agrupar mensajes de la misma manera. El UX se volvió uniforme; ahora es más fácil interactuar con él en todo el ecosistema, el comportamiento es más esperado y predecible.\\n\\n  * El lenguaje de UX se volvió unificado — los chats de asistentes en distintos productos ahora se sienten como parte de un mismo ecosistema. Los usuarios ven un comportamiento predecible: el mismo streaming, el mismo manejo de errores, patrones de interacción comunes. \\n\\n  * La velocidad de desarrollo del UI del chat es mucho mayor. \\n\\n  * Evolución centralizada — nuevas funcionalidades como el tipo de contenido thinking o un mejor trabajo con tools se añaden una sola vez y quedan disponibles automáticamente para todos. \\n\\n  * La biblioteca se convirtió en la base para la formación de estándares de interfaces de IA en el ecosistema.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Qué sigue{#further}\n\n\n          Ahora, sobre los planes. Identificamos varias direcciones: \n\n            * Mejorar el rendimiento mediante virtualización para trabajar con historiales de chat muy grandes. \n\n            * Ampliar los escenarios base para nuevas capacidades de los agentes de IA, que se están desarrollando activamente. \n\n            * Añadir utilidades para simplificar el mapeo de datos de modelos de IA populares a nuestro modelo de datos del chat. \n\n          Además, desarrollaremos la documentación y los ejemplos. Y, por\n          supuesto, el crecimiento de la comunidad — queremos que la biblioteca\n          sea útil no solo dentro de la compañía, sino también para\n          desarrolladores externos.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Cómo probar AIKit{#try}\n\n\n          Entrad en la [sección de la\n          biblioteca](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}\n          en nuestro sitio web. Si estáis creando vuestro propio asistente de\n          IA, queréis una interfaz de chat rápida y predecible y ya usáis Gravity\n          UI (o estáis dispuestos a probarlo), echad un vistazo al README y a\n          los ejemplos. Y también agradeceremos el feedback — abrid issues,\n          enviad PRs y contadnos qué más necesitáis para vuestros escenarios.\n\n\n          Si le gusta nuestro proyecto, estaremos encantados de recibir ⭐️ en\n          [AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"} y\n          [UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"}!\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "initial en",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 117,
  "summary": null,
  "versionId": 268,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "ru",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "ru-ru",
      "publishedVersionId": null
    },
    {
      "regionCode": "en",
      "publishedVersionId": 268
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "Blog",
    "url": "/blog"
  },
  "voiceovers": []
}