{
    "id": 71,
    "name": "blog/graph",
    "createdAt": "2026-01-15T13:00:46.903Z",
    "updatedAt": "2026-01-15T13:00:46.903Z",
    "type": "default",
    "isDeleted": false,
    "versionOnTranslationId": null,
    "searchCategorySlug": "blog",
    "regions": [],
    "pageId": 71,
    "regionCode": "en",
    "publishedVersionId": 216,
    "lastVersionId": 216,
    "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#CCDAFF'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/speaker.jpg\n          =80x)\n\n\n          **安德烈·谢切季宁**\n\n          高级界面开发工程师\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          本文内容：\n\n            - [任务从何而来](#task)\n            - [我们如何走到解决方案](#solution)\n            - [定制化](#customization)\n            - [我们的图（Graph）库：优势与使用方法](#library)\n            - [有没有类似方案？](#analogs)\n            - [未来计划](#future)\n            - [试用并加入我们](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          你好！我叫安德烈，是 Yandex 基础设施服务 User Experience 团队的界面开发工程师。\n          我们在开发 Gravity UI——一个开源设计系统与 React 组件库，\n          公司内外有数十个产品在使用。\n          今天我会讲讲：我们如何遇到复杂图的可视化任务，\n          为什么现有方案无法满足需求，\n          以及最终 @gravity‑ui/graph 这套库是如何诞生的——并且我们决定将它开源给社区。\n\n\n          这个故事始于一个很现实的问题：我们需要渲染包含 10,000+ 元素的图，\n          且节点里还要有可交互组件。\n          在 Yandex 有很多项目，用户会创建复杂的数据处理流水线——\n          从简单的 ETL 过程到机器学习。\n          当这些流水线以程序方式生成时，块（block）数量可能达到数万。\n\n\n          现有方案不令人满意：\n\n            * **HTML/SVG 库** 外观漂亮、开发体验好，但在几百个元素时就开始卡顿。\n            * **Canvas 方案** 性能没问题，但要做复杂 UI 元素需要写大量代码。\n\n          在 Canvas 里画一个圆角渐变按钮并不难。\n          但当你需要自定义复杂控件或布局时问题就出现了——\n          你得写几十行低层绘制指令。\n          每个界面元素都得从零实现——从点击处理到动画。\n          而我们需要的是完整的 UI 组件：按钮、选择器、输入框、拖拽（drag‑and‑drop）。\n\n\n          我们决定不在 Canvas 与 HTML 之间二选一，而是同时利用两者的优势。\n          思路很简单：根据用户观察图的“距离”（缩放级别）自动切换渲染模式。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: |\n\n          #### 自己试试看\n\n            * [GitHub 仓库](https://github.com/gravity-ui/graph){target=\"_blank\"}\n            * [带示例的 Storybook](https://preview.gravity-ui.com/graph/){target=\"_blank\"}\n            * [Playground](https://gravity-ui.com/ru/libraries/graph/playground){target=\"_blank\"}\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 任务从何而来{#task}\n\n\n          ### Nirvana 与它的图\n\n\n          在 Yandex，我们有一个叫 Nirvana 的服务，用于创建与执行数据处理图\n          （我们在 2018 年就\n          [写过](https://habr.com/ru/companies/yandex/articles/351016/){target=\"_blank\"}）。\n          这是一个很大、很流行、存在已久的服务。\n\n\n          有些用户手工创建图——用鼠标拖拽、添加块、连接它们。\n          这种图没有问题：块不多，一切运行良好。\n          但也有项目会以程序方式生成图。\n          困难就从这里开始：他们可以在一个图里放入多达 10,000 个操作。\n          大概是这样：\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          {% cut \"还有这样：\" %}\n\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-1.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-2.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-3.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-4.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-5.png\n          =830x)\n\n\n          {% endcut %}\n\n\n          这种规模的图，常规的 HTML + SVG 组合根本扛不住。\n          浏览器开始卡顿、内存泄漏，用户体验很糟。\n          我们尝试过硬优化 HTML 渲染，但迟早会碰到物理极限——\n          DOM 并不是为“同时可见的上千个浮动交互元素”而设计的。\n\n\n          需要另一种方案，而在浏览器里我们只剩 Canvas。\n          只有它能提供所需性能。\n\n\n          第一反应是找现成方案。当时是 2017–2018 年，\n          我们翻遍了流行的 Canvas 或图渲染库，\n          但所有方案都卡在同一个问题上：\n          要么用 Canvas + 原始元素，要么用 HTML/SVG 并牺牲性能。\n\n\n          如果不做选择呢？\n\n\n          ### 细节层级（Level of Details）：来自游戏开发的灵感\n\n\n          在游戏开发与制图领域有一个很棒的概念——细节层级（LOD）。\n          这项技术源于一个现实需求：如何展示一个巨大的世界而不把性能拖垮？\n\n\n          关键点很简单：同一个对象可以有多个细节级别，取决于观察距离。\n          在游戏里尤其明显：\n\n            * 远处看到的是山——简单多边形 + 基础贴图。\n            * 走近一些——出现细节：草、石头、阴影。\n            * 更近——能看到树叶。\n\n          当玩家站在山顶眺望远方时，没有人会去渲染草地的百万级多边形。\n\n\n          地图也是同样的原理——每个缩放级别都有自己的数据与细节：\n\n            * 大洲尺度——只显示国家。\n            * 放大到城市——出现街道与城区。\n            * 再近——门牌号、咖啡馆、公交站。\n\n          我们意识到：在 10,000 个块的图的远景尺度下，\n          用户并不需要可交互按钮——他们看不见，也无法操作。\n\n\n          更重要的是，尝试同时渲染 10,000 个 HTML 元素会让浏览器冻结。\n          但当用户放大到某个区域时，可见块数量会急剧下降——\n          从 10,000 变成比如 50。\n          这时就能腾出资源，用于具备丰富交互性的 HTML 组件。\n\n\n          ### 我们的 LOD 方案：三层细节\n\n\n          #### Minimalistic（缩放 0.1–0.3）——Canvas + 简单图元\n\n\n          在此模式下，用户看到系统的整体架构：\n          主要块组在哪里、彼此如何连接。\n          每个块都是一个带基础颜色编码的简单矩形。\n          没有文本、按钮或细节图标。\n          但可以舒适地渲染成千上万的元素。\n          在这一层，用户选择要进一步查看的区域。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Schematic（缩放 0.3–0.7）——Canvas + 细节\n\n\n          出现块名称、状态图标、连接锚点。\n          文本由 Canvas API 绘制——速度快，但样式能力有限。\n          块之间的连接也更有信息量：可以显示数据流方向、连接状态。\n          这是一个过渡模式：Canvas 的性能 + 基础的信息表达。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic4.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Detailed（缩放 0.7+）——HTML + 完整交互\n\n\n          在这里，块会变成完整的界面组件：\n          带控制按钮、参数输入框、进度条、选择器。\n          你可以使用 HTML/CSS 的全部能力并接入任何 UI 库。\n          在此模式下，viewport 通常只容纳 20–50 个块，\n          非常适合精细操作。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic5.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          **如果用 FPS 来选择细节级别会怎样？**\n\n\n          我们尝试过基于 FPS 选择细节级别的方法。\n          但很快发现这会带来不稳定：性能上升时系统切换到更细节的模式，\n          反而降低 FPS，可能又触发切回——如此循环。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 我们如何走到解决方案{#solution}\n\n\n          LOD 的想法很棒。但实现需要 Canvas 来保证性能——\n          这带来了新的麻烦。在 Canvas 上绘制并不难，\n          难的是交互。\n\n\n          ### 问题：如何知道用户点到了哪里？\n\n\n          在 HTML 里很简单：点击按钮，事件直接到元素上。\n          在 Canvas 里更难：点击的是画布——接下来呢？\n          我们必须自己确定用户点击了哪个元素。\n\n\n          基本有三种做法：\n\n            * Pixel Testing（颜色拾取 / color picking），\n            * Geometric approach（简单遍历所有元素），\n            * Spatial Indexing（空间索引）。\n\n          #### Pixel Testing（颜色拾取 / color picking）\n\n\n          思路很简单：创建第二个不可见 canvas，把场景复制过去，\n          但每个元素用唯一颜色填充，该颜色作为对象 ID。\n          点击时通过 getImageData 读取鼠标指针下像素的颜色，即可得到元素 ID。\n\n\n          #|\n\n          ||**优点**|**缺点**||\n\n          ||* 只需几十行代码即可实现\n\n\n          * 不需要额外的数据结构|* Canvas 的抗锯齿会混色——点击图形边缘可能得到“无效”ID\n\n\n          * 2D Canvas 无法关闭 anti‑aliasing\n\n\n          * 第二张画布会复制内存并使渲染流程翻倍||\n\n          |#\n\n\n          小场景可用，但在 10,000+ 元素时错误率不可接受——因此我们放弃 Pixel Testing。\n\n\n          #### Geometric approach（简单遍历所有元素）\n\n\n          思路也很简单：遍历所有元素并检查点击点是否在元素内部。\n\n\n          #|\n\n          ||**优点**|**缺点**||\n\n          ||* 只需几十行代码即可实现\n\n\n          * 不需要额外的数据结构|* 元素很多时非常慢\n\n\n          * 不适合大型场景||\n\n          |#\n\n\n          #### Spatial Indexing（空间索引）\n\n\n          这是几何法的进化版。几何法卡在元素数量上。\n          空间索引算法会把相近元素分组（通常用树结构），\n          从而把复杂度降低到 log n。\n\n\n          空间索引算法很多，我们选择了 R‑Tree 数据结构，\n          使用库 [rbush](https://github.com/mourner/rbush){target=\"_blank\"}。\n\n\n          R‑Tree 顾名思义是一棵树：每个对象先放入最小包围矩形（MBR），\n          再把这些矩形聚合成更大的矩形。\n          这样形成一棵树：每个矩形都包含其他矩形。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: >-\n          图片来自维基百科\n          [R‑tree](https://en.wikipedia.org/wiki/R-tree){target=\"_blank\"}\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic6.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          在 RTree 里搜索时，我们沿着树向下（深入矩形）直到命中具体元素。\n          路径通过检测搜索矩形与各节点 MBR 的相交来决定。\n          所有 bounding‑box 连搜索矩形都不碰的分支会立刻被丢弃——\n          因此遍历深度通常限制在 3–5 层，即使在数万元素上搜索也只需微秒级。\n\n\n          这种方法虽然比 pixel testing 慢一些（最佳 O(log n)、最坏 O(n)），\n          但更准确，且对内存要求更低。\n\n\n          #### 事件模型\n\n\n          基于 RTree，我们就能构建事件模型。\n          当用户点击时，我们启动命中测试（hit‑test）：\n          在光标坐标处构造一个 1×1 像素的矩形，并在 R‑Tree 中查找与其相交的元素。\n          找到命中元素后，把事件委派给该元素。\n          若元素没有停止事件，则事件传递给其父元素，一直向上到 root。\n          该模型的行为类似浏览器的事件模型：可以拦截、prevent 或停止冒泡。\n\n\n          正如前面提到的，我们在 hit‑test 时构造的是 1×1 像素矩形——\n          这意味着我们也可以构造任意尺寸的矩形。\n          这将帮助我们实现另一个非常重要的优化：Spatial Culling。\n\n\n          ### Spatial Culling（空间裁剪）\n\n\n          Spatial Culling 是一种渲染优化技术，目标是“不画不可见的东西”。\n          例如：不画在相机视野之外的对象，或被其他元素遮挡的对象。\n          由于我们的图是在 2D 空间中绘制，因此只要不绘制 viewport（可视区域）之外的对象就够了。\n\n\n          工作方式：\n\n            * 相机每次移动或缩放时，我们构造一个与当前 viewport 相同的矩形；\n            * 在 R‑Tree 中查找与其相交的元素；\n            * 得到真正可见的元素列表；\n            * 只渲染它们，其他全部跳过。\n\n          该技巧让性能几乎不再依赖元素总数：\n          如果画面里只容纳 40 个块——库就只画 40 个，而不是画屏幕外的数万。\n          在远景尺度下，viewport 内元素较多，因此我们绘制轻量的 Canvas 图元；\n          当放大时，元素数量下降，释放的资源允许切到 HTML 模式获得完整细节。\n\n\n          综上，我们得到一个简单的体系：\n\n            * Canvas 负责速度，\n            * HTML 负责交互性，\n            * R‑Tree 与 Spatial Culling 在背后把它们无缝整合为一个系统，从而快速判断哪些元素可以画在 HTML 层。\n\n          相机移动时，小 viewport 只向 R‑Tree 查询当前画面里真正存在的对象。\n          这种方式让我们能够绘制真正的大型图，\n          或至少在用户不限制 viewport 之前保持足够的性能余量。\n\n\n          因此，库的核心包含：\n\n            * 使用简单图元的 Canvas 模式；\n            * 具备完整细节的 HTML 模式；\n            * 用于性能优化的 R‑Tree 与 Spatial Culling；\n            * 熟悉的事件模型。\n\n          但要用于生产环境，这还不够：我们必须能扩展库并按需定制。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 定制化{#customization}\n\n\n          库提供两种相辅相成的扩展/改造方式：\n\n            * 重写基础组件：修改标准 Block、Anchor、Connection 的逻辑。\n            * 通过层（Layers）扩展：在现有场景的上层/下层添加本质上全新的功能。\n\n          ### 重写组件\n\n\n          当需要修改现有元素的外观或行为时，我们从基类继承并重写关键方法。\n          然后用自定义名称注册组件。\n\n\n          #### 定制块（Block）\n\n\n          例如，如果你需要在块上显示进度条的图——\n          比如用来展示流水线里任务的执行状态——\n          你可以很容易地定制标准块：\n\n\n          ```json\n\n          import { CanvasBlock } from \"@gravity‑ui/graph\";\n\n\n          class ProgressBlock extends CanvasBlock {\n            // 带圆角的块基础形状\n            public override renderBody(ctx: CanvasRenderingContext2D): void {\n              ctx.fillStyle = \"#ddd\";\n              ctx.beginPath();\n              ctx.roundRect(this.state.x, this.state.y, this.state.width, this.state.height, 12);\n              ctx.fill();\n              ctx.closePath();\n            }\n\n            public renderSchematicView(ctx: CanvasRenderingContext2D): void {\n              const progress = this.state.meta?.progress || 0;\n\n              // 绘制块的底形\n              this.renderBody(ctx);\n\n              // 带颜色指示的进度条\n              const progressWidth = (this.state.width - 20) * (progress / 100);\n              ctx.fillStyle = progress < 50 ? \"#ff6b6b\" : progress < 80 ? \"#feca57\" : \"#48cae4\";\n              ctx.fillRect(this.state.x + 10, this.state.y + this.state.height - 15, progressWidth, 8);\n\n              // 进度条边框\n              ctx.strokeStyle = \"#ddd\";\n              ctx.lineWidth = 1;\n              ctx.strokeRect(this.state.x + 10, this.state.y + this.state.height - 15, this.state.width - 20, 8);\n\n              // 百分比与名称文本\n              ctx.fillStyle = \"#2d3436\";\n              ctx.font = \"12px Arial\";\n              ctx.textAlign = \"center\";\n              ctx.fillText(`${Math.round(progress)}%`, this.state.x + this.state.width / 2, this.state.y + 20);\n              ctx.fillText(this.state.name, this.state.x + this.state.width / 2, this.state.y + 40);\n            }\n          }\n\n          ```\n\n\n          #### 定制连接（Connection）\n\n\n          同理，如果你需要改变连线的行为与外观——\n          例如显示块之间数据流的强度——你可以创建自定义连接：\n\n\n          ```json\n\n          import { BlockConnection } from \"@gravity-ui/graph\";\n\n\n          class DataFlowConnection extends BlockConnection {\n            public override style(ctx: CanvasRenderingContext2D) {\n              // 从相连的块中获取流量数据\n              const sourceBlock = this.sourceBlock;\n              const targetBlock = this.targetBlock;\n\n              const sourceProgress = sourceBlock?.state.meta?.progress || 0;\n              const targetProgress = targetBlock?.state.meta?.progress || 0;\n\n              // 根据块的进度计算流量强度\n              const flowRate = Math.min(sourceProgress, targetProgress);\n              const isActive = flowRate > 10; // 进度 > 10% 视为流处于活跃状态\n\n              if (isActive) {\n                // 活跃流 —— 粗的绿色线\n                ctx.strokeStyle = \"#00b894\";\n                ctx.lineWidth = Math.max(2, Math.min(6, flowRate / 20));\n              } else {\n                // 非活跃流 —— 灰色虚线\n                ctx.strokeStyle = \"#ddd\";\n                ctx.lineWidth = this.context.camera.getCameraScale();\n                ctx.setLineDash([5, 5]);\n              }\n\n              return { type: \"stroke\" };\n            }\n          }\n\n          ```\n\n\n          #### 使用自定义组件\n\n\n          在图的配置中注册创建的组件：\n\n\n          ```json\n\n          const customGraph = new Graph({\n            blocks: [\n              {\n                id: \"task1\",\n                is: \"progress\",\n                x: 100,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Data Processing\",\n                meta: { progress: 75 },\n              },\n              {\n                id: \"task2\",\n                is: \"progress\",\n                x: 400,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Analysis\",\n                meta: { progress: 30 },\n              },\n              {\n                id: \"task3\",\n                is: \"progress\",\n                x: 700,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Output\",\n                meta: { progress: 5 },\n              },\n            ],\n            connections: [\n              { sourceBlockId: \"task1\", targetBlockId: \"task2\" },\n              { sourceBlockId: \"task2\", targetBlockId: \"task3\" },\n            ],\n            settings: {\n              // 注册自定义块\n              blockComponents: {\n                'progress': ProgressBlock,\n              },\n              // 为所有连线注册自定义连接\n              connection: DataFlowConnection,\n              useBezierConnections: true,\n            },\n          });\n\n\n          customGraph.setEntities({\n            blocks: [\n              {\n              is: 'progress',\n              id: '1',\n              name: \"progress block',\n              x: 10, \n              y: 10, \n              width: 10, \n              height: 10,\n              anchors: [],\n              selected: false,\n              }\n            ]\n          })\n\n\n          customGraph.start();\n\n          ```\n\n\n          #### 结果\n\n\n          最终你会得到一张图，其中：\n\n            * 块以颜色提示显示当前进度；\n            * 连线可视化数据流：活跃流为绿色且更粗，不活跃流为灰色虚线；\n            * 缩放时，块会自动切换到具备完整交互的 HTML 模式。\n\n          ### 通过层（Layers）扩展\n\n\n          层（Layer）是额外的 Canvas 或 HTML 元素，会被插入到图的“空间”中。\n          本质上，每一层都是独立的渲染通道：\n          可以包含自己的 canvas（用于快速图形），或 HTML 容器（用于复杂交互元素）。\n\n\n          顺便说一句：我们库的 React 集成正是通过层来工作的——\n          React 组件通过 React Portal 渲染进 HTML 层。\n\n\n          #### 层的架构\n\n\n          层是解决 Canvas vs HTML 两难的另一个关键机制。\n          层会同步 Canvas 与 HTML 元素的位置，确保它们正确叠加。\n          这样就能在同一坐标空间内无缝切换 Canvas 与 HTML。\n          图由相互独立、彼此叠加的层构成：\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic7.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          层可以在两种坐标系下工作：\n\n            * 绑定到图（`transformByCameraPosition: true`）：\n\n              * 元素随相机一起移动，\n              * 块、连接、图元素。\n\n            * 固定在屏幕（`transformByCameraPosition: false`）：\n\n              * 平移时保持原位，\n              * 工具栏、图例、UI 控件。\n\n          #### React 集成如何实现\n\n\n          具备 React 集成的层很好地展示了“层”的含义。\n          先看一个组件：它会高亮相机可视区域内的块列表。\n          为此我们要订阅相机变化，并在每次变化后检查相机 viewport 与元素 hitbox 的相交。\n\n\n          ```json\n\n          import { Graph } from \"@gravity-ui/graph\";\n\n\n          const BlocksList = ({ graph, renderBlock }: { graph: Graph,\n          renderBlock: (graph: Graph, block: TBlock) => React.JSX.Element }) =>\n          {\n            const [blocks, setBlocks] = useState([]);\n\n            const updateVisibleList = useCallback(() => {\n              const cameraState = graph.cameraService.getCameraState();\n              const CAMERA_VIEWPORT_TRESHOLD = 0.5;\n              const x = -cameraState.relativeX - cameraState.relativeWidth * CAMERA_VIEWPORT_TRESHOLD;\n              const y = -cameraState.relativeY - cameraState.relativeHeight * CAMERA_VIEWPORT_TRESHOLD;\n              const width = -cameraState.relativeX + cameraState.relativeWidth * (1 + CAMERA_VIEWPORT_TRESHOLD) - x;\n              const height = -cameraState.relativeY + cameraState.relativeHeight * (1 + CAMERA_VIEWPORT_TRESHOLD) - y;\n              \n              const blocks = graph\n                .getElementsOverRect(\n                  {\n                    x,\n                    y,\n                    width,\n                    height,\n                  }, // 定义在哪个区域内查找块列表\n                  [CanvasBlock] // 定义在相机可视范围内要查找的元素类型\n                ).map((component) => component.connectedState); // 获取块模型列表\n\n                setBlocks(blocks);\n            });\n\n              useGraphEvent(graph, \"camera-change\", ({ scale }) => {\n                if (scale >= 0.7) {\n                  // 若缩放比例大于 0.7，则更新块列表\n                  updateVisibleList()\n                  return;\n                }\n                setBlocks([]);\n              });\n\n              return blocks.map(block => <React.Fragment key={block.id}>{renderBlock(graphObject, block)}</React.Fragment>)\n          }\n\n          ```\n\n\n          接下来看看将使用该组件的层的定义。\n\n\n          ```json\n\n          import { Layer } from '@gravity-ui/graph';\n\n\n          class ReactLayer extends Layer {\n            constructor(props: TReactLayerProps) {\n              super({\n                html: {\n                  zIndex: 3, // 将该层置于其他层之上\n                  classNames: [\"no-user-select\"], // 添加一个 class 以禁用文本选择\n                  transformByCameraPosition: true, // 该层绑定相机：会随相机一起移动\n                },\n                ...props,\n              });\n            }\n\n            public renderPortal(renderBlock: <T extends TBlock>(block: T) => React.JSX.Element) {\n              if (!this.getHTML()) {\n                return null;\n              }\n\n              const htmlLayer = this.getHTML() as HTMLDivElement;\n\n              return createPortal(\n                React.createElement(BlocksList, {\n                  graph: this.context.graph,\n                  renderBlock: renderBlock,\n                }),\n                htmlLayer,\n              );\n            }\n          }\n\n          ```\n\n\n          现在我们可以在应用中使用该层。\n\n\n          ```json\n\n          import { Flex } from \"@gravity-ui/uikit\";\n\n\n          const graph = useMemo(() => new Graph());\n\n          const containerRef = useRef<HTMLDivElement>();\n\n\n          useEffect(() => {\n              if (containerRef.current) {\n                graph.attach(containerRef.current);\n              }\n\n              return () => {\n                graph.detach();\n              };\n            }, [graph, containerRef]);\n\n\n          const reactLayer = useLayer(graph, ReactLayer, {});\n\n\n          const renderBlock = useCallback((graph, block) => <Block graph={graph}\n          block={block}>{block.name}</Block>)\n\n            return (\n              <div>\n                <div style={{ position: \"absolute\", overflow: \"hidden\", width: \"100%\", height: \"100%\" }} ref={containerRef}>\n                  {graph && reactLayer && reactLayer.renderPortal(renderBlock)}\n                </div>\n              </div>\n            );\n          ```\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          总体来说一切都很简单。上面描述的内容不需要你自己实现——\n          都已经写好并可直接使用。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 我们的图（Graph）库：优势与使用方法{#library}\n\n\n          当我们开始做这套库时，最核心的问题是：\n          如何让开发者不必在性能与开发体验之间做选择？\n          答案是把这种选择自动化。\n\n\n          ### 优势\n\n\n          #### 性能 + 便利\n\n\n          [@gravity‑ui/graph](https://github.com/gravity-ui/graph){target=\"_blank\"}\n          会根据缩放自动在 Canvas 与 HTML 之间切换。\n          这意味着你可以获得：\n\n            * 在包含数千元素的图上稳定 60 FPS。\n            * 在细节查看时使用具备丰富交互的完整 HTML 组件。\n            * 与渲染方式无关的统一事件模型——click、mouseenter 在 Canvas 与 HTML 上表现一致。\n\n          #### 与 UI 库兼容\n\n\n          一个重要优势是：它兼容任意 UI 库。\n          如果你的团队使用：\n\n            * Gravity UI，\n            * Material‑UI，\n            * Ant Design，\n            * 自定义组件。\n\n          ……你无需放弃它们！当放大图时会自动切到 HTML 模式，\n          在那里你熟悉的 `Button`、`Select`、`DatePicker`，\n          以你需要的主题色正常工作，就像在普通 React 应用中一样。\n\n\n          #### 与框架无关（Framework agnostic）\n\n\n          虽然我们用 React 实现了基础 HTML renderer，\n          但我们尽量让库保持“与框架无关”。\n          这意味着在必要时，你可以相对容易地实现一个层，用于集成你喜欢的框架。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## 有没有类似方案？{#analogs}\\n\\n目前市面上用于绘制图的方案很多：从付费方案如 [yFiles](https://yfiles.dev/){target=\\\"_blank\\\"}、[JointJS](https://github.com/clientIO/joint){target=\\\"_blank\\\"}，到开源方案 [Foblex Flow](https://github.com/Foblex/f-flow){target=\\\"_blank\\\"}、[baklavajs](https://github.com/newcat/baklavajs){target=\\\"_blank\\\"}、[jsPlumb](https://github.com/jsplumb/community-edition){target=\\\"_blank\\\"}。不过我们对比时主要关注 [@antv/g6](https://github.com/antvis/G6){target=\\\"_blank\\\"} 和 [React Flow](https://github.com/xyflow/xyflow){target=\\\"_blank\\\"} 这两个最流行的工具。它们各有特点。\\n\\nReact Flow 是一款不错的库，专注于构建 node‑based 接口。它功能很强，但由于使用 SVG 和 HTML，性能相对一般。适合你能确定图不会超过 100–200 个块的场景。\\n\\n@antv/g6 则功能很多，支持 Canvas，尤其是 WebGL。直接拿 @antv/g6 和 @gravity‑ui/graph 做对比可能不太合适：他们更偏向图与图表（diagram/chart）构建，不过也支持 node‑based UI。因此如果你不仅要 node‑based 界面，还要画图表，antv/g6 会是合适选择。\\n\\n虽然 @antv/g6 既支持 canvas/webgl 又支持 html/svg，但切换规则需要你手动管理，而且必须做对。它的性能远快于 React Flow，但仍有一些问题。尽管声称支持 WebGL，但看他们的 [压力测试](https://g6.antv.antgroup.com/en/examples/performance/massive-data#60000){target=\\\"_blank\\\"} 可以发现：在 60k 节点时库无法保持动态表现——在 MacBook M3 上渲染一帧用了 4 秒。对比我们的 [压力测试](https://preview.gravity-ui.com/graph/?path=/story/stories-main-grapheditor--graph-stress-test){target=\\\"_blank\\\"}：同一台 Macbook M3 上 111k 节点与 109k 连线，渲染整个场景仅 ~60ms，约为 ~15–20FPS。这个 FPS 不算高，但借助 Spatial Culling 可以限制 viewport，从而提升交互响应。尽管维护者曾 [表示](https://github.com/antvis/G6/issues/1597){target=\\\"_blank\\\"} 希望实现 100k 节点 30 FPS 的渲染，但显然目前还未达到。\\n\\n另外一个 @gravity‑ui/graph 的优势是 bundle 体积。\\n\\n#|\\n|||Bundle size Minified|Bundle size Minified + Gzipped||\\n||@antv/g6 [bundlephobia](https://bundlephobia.com/package/@antv/g6@5.0.49){target=\\\"_blank\\\"}|1.1 MB|324.5\\_kB||\\n||react flow [bundlephobia](https://bundlephobia.com/package/@xyflow/react@12.8.1){target=\\\"_blank\\\"}|181.2\\_kB|56.4\\_kB||\\n||@gravity-ui/graph [bundlephobia](https://bundlephobia.com/package/@gravity-ui/graph){target=\\\"_blank\\\"}|2.2\\_kB|672\\_B||\\n|#\\n\\n尽管这两款库在性能或集成体验上都很强，但 @gravity‑ui/graph 仍有一系列优势——它能在真正大型的图上提供性能，同时保持良好的 UI/UX，并简化开发。\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 未来计划{#future}\n\n\n          目前库在性能上已经有足够余量来覆盖大多数任务。\n          因此在近期，我们会把更多精力放在围绕库的生态建设上——\n          开发层（插件）、为其他库与框架提供集成（Angular/Vue/Svelte 等），\n          增加对触控设备的支持、适配移动端浏览器，并整体提升 UX/DX。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 试用并加入我们{#try}\n\n\n          在 [仓库](https://github.com/gravity-ui/graph){target=\"_blank\"} 中\n          你可以找到一套完全可用的库：\n\n            * 基于 Canvas + R‑Tree 的核心（≈ 30K 行代码），\n            * React 集成，\n            * 带示例的 Storybook。\n\n          一行即可安装：\n\n\n          `npm install @gravity-ui/graph`\n\n\n          --------------\n\n\n          相当长一段时间里，现在名为 @gravity‑ui/graph 的库\n          一直是 Nirvana 内部工具，而这套方案在实践中表现很好。\n          现在我们希望分享这些成果，帮助外部开发者更简单、更快速、更高性能地绘制自己的图。\n\n\n          我们希望在开源社区里推动复杂图展示方式的标准化——\n          太多团队在重复造轮子，或被不合适的工具折磨。\n\n\n          因此我们非常需要你的反馈：不同项目会带来不同的边界场景（edge cases），\n          这能推动库持续演进。\n          这将帮助我们完善库，并更快壮大 Gravity UI 的生态。\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
    "title": "",
    "noIndex": false,
    "shareTitle": null,
    "shareDescription": null,
    "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png",
    "pageLocaleId": null,
    "author": "timofeyevvv",
    "metaDescription": null,
    "keywords": [],
    "shareGenTitle": null,
    "canonicalLink": null,
    "sharingType": "semi-full",
    "sharingTheme": "dark",
    "comment": "sharing pic",
    "shareImageUrl": "https://storage.cloud-preprod.yandex.net/ui-api-ru-preprod-stable-share-generator-screenshots/cache/b155df2ab692d6e154ff809a7d91b9ad4789de53.png",
    "pageRegionId": 76,
    "summary": null,
    "versionId": 216,
    "service": null,
    "solution": null,
    "locales": [
      {
        "id": 75,
        "pageId": 71,
        "locale": "ru",
        "createdAt": "2026-01-15T11:26:48.440Z",
        "updatedAt": "2026-01-15T11:26:48.519Z",
        "publishedVersionId": null,
        "lastVersionId": 195
      },
      {
        "id": 76,
        "pageId": 71,
        "locale": "en",
        "createdAt": "2026-01-15T11:26:48.532Z",
        "updatedAt": "2026-01-15T11:26:48.609Z",
        "publishedVersionId": null,
        "lastVersionId": 196
      }
    ],
    "pageRegions": [
      {
        "regionCode": "ru-ru",
        "publishedVersionId": 199
      },
      {
        "regionCode": "en",
        "publishedVersionId": 216
      }
    ],
    "searchCategory": {
      "id": 7,
      "slug": "blog",
      "title": "Blog",
      "url": "/blog"
    },
    "voiceovers": []
  }
  