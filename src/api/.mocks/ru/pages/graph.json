{
    "id": 71,
    "name": "blog/graph",
    "createdAt": "2026-01-15T11:28:28.437Z",
    "updatedAt": "2026-01-15T11:28:28.437Z",
    "type": "default",
    "isDeleted": false,
    "versionOnTranslationId": null,
    "searchCategorySlug": "blog",
    "regions": [],
    "pageId": 71,
    "regionCode": "ru-ru",
    "publishedVersionId": 199,
    "lastVersionId": 199,
    "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#CCDAFF'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/speaker.jpg\n          =80x)\n\n\n          **Андрей Щетинин**\n\n          Старший разработчик интерфейсов\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          В этой статье:\n\n            - [Откуда взялась задача](#task)\n            - [Как мы пришли к решению](#solution)\n            - [Кастомизация](#customization)\n            - [Наша библиотека графов: в чем плюсы и как пользоваться](#library)\n            - [А есть ли аналоги?](#analogs)\n            - [Планы на будущее](#future)\n            - [Попробуйте и присоединяйтесь](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Привет! Меня зовут Андрей, я разработчик интерфейсов в команде User\n          Experience инфраструктурных сервисов Яндекса. Мы развиваем Gravity UI\n          — опенсорсную дизайн‑систему и библиотеку React‑компонентов, которую\n          используют десятки продуктов внутри компании и за её пределами.\n          Сегодня расскажу, как мы столкнулись с задачей визуализации сложных\n          графов, почему существующие решения нас не устроили, и как в итоге\n          появилась @gravity‑ui/graph — библиотека, которую мы решили сделать\n          открытой для сообщества.\n\n\n          Эта история началась с практической проблемы: нам нужно было рендерить\n          графы на 10 000+ элементов с интерактивными компонентами. В Яндексе\n          много проектов, где пользователи создают сложные пайплайны обработки\n          данных — от простых ETL‑процессов до машинного обучения. Когда такие\n          пайплайны создаются программно, количество блоков может достигать\n          десятков тысяч.\n\n\n          Существующие решения нас не устраивали:\n\n            * **HTML/SVG‑библиотеки** красиво выглядят и удобны в разработке, но начинают тормозить уже на сотнях элементов.\n            * **Canvas‑решения** справляются с производительностью, но требуют огромного количества кода для создания сложных UI‑элементов.\n\n          Нарисовать кнопку с закруглёнными углами и градиентом в Canvas\n          несложно. Однако проблемы появляются, когда нужно создать свои сложные\n          контролы или разметку — потребуется писать десятки строк\n          низкоуровневых команд рисования. Каждый элемент интерфейса приходится\n          программировать с нуля — от обработки кликов до анимаций. А нам нужны\n          были полноценные UI‑компоненты: кнопки, селекты, поля ввода,\n          drag‑and‑drop.\n\n\n          Мы решили не выбирать между Canvas и HTML, а использовать всё лучшее\n          из обеих технологий. Идея была проста: автоматически переключаться\n          между режимами в зависимости от того, насколько близко пользователь\n          смотрит на граф.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: |\n\n          #### Попробуйте сами\n\n            * [GitHub репозиторий](https://github.com/gravity-ui/graph){target=\"_blank\"}\n            * [Storybook с примерами](https://preview.gravity-ui.com/graph/){target=\"_blank\"}\n            * [Playground](https://gravity-ui.com/ru/libraries/graph/playground){target=\"_blank\"}\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Откуда взялась задача{#task}\n\n\n          ### Нирвана и её графы\n\n\n          У нас в Яндексе есть сервис Нирвана для создания и выполнения графов\n          обработки данных (мы про неё\n          [писали](https://habr.com/ru/companies/yandex/articles/351016/){target=\"_blank\"}\n          аж в 2018 году). Сервис большой, популярный, существует уже давно.\n\n\n          Часть пользователей создаёт графы руками — водят мышкой, добавляют\n          блоки, соединяют их. С такими графами проблем нет: блоков не много, и\n          всё работает отлично. Но есть проекты, которые создают графы\n          программно. И здесь начинаются сложности: они могут положить в один\n          граф до 10 000 операций. И получается такое:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          {% cut \"И такое:\" %}\n\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-1.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-2.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-3.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-4.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-5.png\n          =830x)\n\n\n          {% endcut %}\n\n\n          Такие графы обычная связка HTML + SVG просто не тянет. Браузер\n          начинает тормозить, память утекает, пользователь страдает. Мы пытались\n          решить проблему в лоб: оптимизировать рендеринг HTML, но рано или\n          поздно упирались в физические ограничения — DOM просто не рассчитан на\n          тысячи одновременно видимых плавающих интерактивных элементов.\n\n\n          Нужно другое решение, и в браузере у нас остался только Canvas. Только\n          он сможет обеспечить необходимую производительность.\n\n\n          Первая мысль — найти готовое решение. На дворе был 2017–2018 год, и мы\n          перелопатили популярные библиотеки для Canvas или рендеринга графов,\n          но все решения упирались в одну и ту же проблему: либо используй\n          Canvas и примитивные элементы, либо используй HTML/SVG и жертвуй\n          производительностью.\n\n\n          А что если не выбирать?\n\n\n          ### Level of Details: вдохновение из GameDev\n\n\n          В GameDev и картографии есть классная концепция — Level of Details\n          (LOD). Эта техника родилась из необходимости — как показать огромный\n          мир, не убив производительность?\n\n\n          Суть простая: у одного объекта может быть несколько уровней\n          детализации в зависимости от того, как близко на него смотрят. В играх\n          это особенно заметно:\n\n            * Вдалеке видны горы — это простые полигоны с базовой текстурой.\n            * Подходите ближе — появляютcя детали: трава, камни, тени.\n            * Ещё ближе — видны отдельные листья на деревьях.\n\n          Никто не рендерит миллионы полигонов травы, когда игрок стоит на\n          вершине горы и смотрит вдаль.\n\n\n          В картах принцип тот же — у каждого уровня масштаба свой набор данных\n          и своя детализация:\n\n            * Масштаб континента — видны только страны.\n            * Приближаетесь к городу — появляются улицы и районы.\n            * Ещё ближе — номера домов, кафе, автобусные остановки.\n\n          Мы поняли: пользователю не нужны интерактивные кнопки на большом\n          масштабе графа из 10 000 блоков — он их всё равно не увидит и не\n          сможет с ними работать.\n\n\n          Более того, попытка отрендерить 10 000 HTML‑элементов одновременно\n          приведёт к фризу браузера. Но когда он зумится на конкретную область,\n          количество видимых блоков резко падает — с 10 000 до, скажем, 50. Вот\n          тут‑то и освобождаются ресурсы для HTML‑компонентов с богатой\n          интерактивностью.\n\n\n          ### Три уровня нашей схемы Level of Details\n\n\n          #### Minimalistic (масштаб 0,1–0,3) — Canvas с простыми примитивами\n\n\n          В этом режиме пользователь видит общую архитектуру системы: где\n          расположены основные группы блоков, как они соединены между собой.\n          Каждый блок — это простой прямоугольник с базовой цветовой кодировкой.\n          Никаких текстов, кнопок, детализированных иконок. Зато можно комфортно\n          рендерить тысячи элементов. На этом уровне пользователь выбирает\n          область для детального изучения.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Schematic (масштаб 0,3–0,7) — Canvas с деталями\n\n\n          Появляются названия блоков, иконки состояний, якоря для соединений.\n          Текст рендерится средствами Canvas API — это быстро, но возможности\n          стилизации ограничены. Связи между блоками становятся более\n          информативными: можно показать направление потока данных, статус\n          соединения. Это переходный режим, где производительность Canvas\n          сочетается с базовой информативностью.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic4.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Detailed (масштаб 0,7+) — HTML с полной интерактивностью\n\n\n          Здесь блоки превращаются в полноценные компоненты интерфейса: с\n          кнопками управления, полями для параметров, прогресс‑барами,\n          селектами. Можно использовать любые возможности HTML/CSS, подключать\n          UI‑библиотеки. В этом режиме в viewport обычно помещается не больше\n          20–50 блоков, что комфортно для детальной работы.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic5.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          **А что если считать FPS для выбора уровня детализации?**\n\n\n          У нас были подходы к выборе детализации основе FPS. Но оказалось что\n          такой подход создаёт нестабильность — при росте производительности\n          система переключается на более детальный режим, что снижает FPS и\n          может вызывать переключение обратно — и так по кругу.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Как мы пришли к решению{#solution}\n\n\n          Хорошо, LOD — это круто. Но реализация потребует Canvas для\n          производительности, а это новая головная боль. Рисовать на Canvas это\n          не очень сложно — проблемы появляются когда нужно сделать\n          интерактивность.\n\n\n          ### Проблема: как понять, куда кликнул пользователь?\n\n\n          В HTML всё просто: кликнул на кнопку — получил событие сразу на\n          элементе. В Canvas сложнее: кликнул на холст — и что дальше? Нужно\n          самим выяснить, на какой элемент кликнул пользователь.\n\n\n          Базово существуют три подхода:\n\n            * Pixel Testing (color picking),\n            * Geometric approach (простой перебор всех элементов),\n            * Spatial Indexing (пространственный индекс).\n\n          #### Pixel Testing (color picking)\n\n\n          Идея проста: создаём второй невидимый canvas, копируем туда сцену, но\n          каждый элемент заливаем уникальным цветом, который будет считаться ID\n          объекта. При клике считываем цвет пикселя под указателем мыши через\n          getImageData и так получаем ID элемента.\n\n\n          #|\n\n          ||**Плюсы**|**Минусы**||\n\n          ||* Реализуется за пару десятков строк\n\n\n          * Не требует дополнительных структур данных|* Сглаживание Canvas\n          смешивает цвета — клик на границе фигуры может дать «невалидный» ID\n\n\n          * Выключение anti‑aliasing в 2D‑Canvas недоступно\n\n\n          * Второй холст дублирует память и удваивает рендер‑проход||\n\n          |#\n\n\n          Для небольших сцен метод годится, но при 10 000+ элементах процент\n          ошибок становится неприемлемым — откладываем Pixel Testing.\n\n\n          #### Geometric approach (простой перебор всех элементов)\n\n\n          Идея проста: перебираем все элементы и проверяем, находится ли точка\n          клика внутри элемента.\n\n\n          #|\n\n          ||**Плюсы**|**Минусы**||\n\n          ||* Реализуется за пару десятков строк\n\n\n          * Не требует дополнительных структур данных|* Очень медленно работает\n          при большом количестве элементов\n\n\n          * Не подходит для больших сцен||\n\n          |#\n\n\n          #### Spatial Indexing\n\n\n          Развитие геометрического подхода. В геометрическом подходе мы\n          упирались в количество элементов. Алгоритмы пространственного индекса\n          стараются как‑то сгруппировать рядом стоящие элементы, используя в\n          основном деревья, что позволяет снизить сложность до log n.\n\n\n          Алгоритмов пространственного индекса довольно много, мы выбрали\n          структуру данных R‑Tree в виде библиотеки\n          [rbush](https://github.com/mourner/rbush){target=\"_blank\"}.\n\n\n          R‑Tree — это, как понятно из названия, дерево, где каждый объект\n          помещается в прямоугольник минимального размера (MBR), а затем эти\n          прямоугольники группируются в более крупные прямоугольники. И так\n          получается дерево, где каждый прямоугольник содержит в себе другие\n          прямоугольники.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: >-\n          Картинка из википедии\n          [R‑tree](https://en.wikipedia.org/wiki/R-tree){target=\"_blank\"}\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic6.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Для поиска в RTree нам нужно спускаться по дереву (вглубь\n          прямоугольника), пока мы не попадём в конкретный элемент. Путь\n          выбирается проверкой пересечения поискового прямоугольника с MBR. Все\n          ветви, чьи bounding‑box даже не задевают поисковый прямоугольник,\n          отбрасываются сразу — именно поэтому глубина обхода обычно\n          ограничивается 3–5 уровнями, а сам поиск занимает микросекунды даже на\n          десятках тысяч элементов.\n\n\n          Этот вариант работает хоть и медленнее (O(log n) в лучшем случае и\n          O(n) в худшем), чем pixel testing, но он точнее и менее требователен к\n          памяти.\n\n\n          #### Событийная модель\n\n\n          На основе RTree мы теперь можем построить нашу событийную модель.\n          Когда пользователь кликает, запускается процедура хит‑тест: формируем\n          прямоугольник размером 1×1 пиксель в координатах курсора и ищем его\n          пересечение в R‑Tree. Получив элемент, в который попадает этот\n          прямоугольник, мы делегируем событие этому элементу. Если элемент не\n          остановил событие, то это событие передаётся его родителю и так до\n          рута. Поведение этой модели похоже на поведение привычной нам\n          событийной модели в браузере. События можно перехватить, запревентить\n          или остановить всплытие.\n\n\n          Как я уже упомянул, при хит‑тесте мы формируем прямоугольник размером\n          1×1 пиксель, а это значит, что мы можем сформировать прямоугольник\n          любого размера. И это нам поможет сделать еще одну очень важную\n          оптимизацию — Spatial Culling.\n\n\n          ### Spatial Culling\n\n\n          Spatial Culling — это техника оптимизации рендеринга, которая нацелена\n          на то, чтобы не рисовать то, что не видно. Например, чтобы не рисовать\n          объекты, которые находятся вне пространства камеры или которые\n          загорожены другими элементами сцены. Так как наш граф рисуется в\n          2D‑пространстве, то нам достаточно не рисовать лишь те объекты,\n          которые находятся вне области видимости камеры (viewport).\n\n\n          Как это работает:\n\n            * при каждом перемещении или зуме камеры мы формируем прямоугольник, равный текущему viewport;\n            * ищем его пересечение в R‑Tree;\n            * результатом становится список элементов, которые действительно видны;\n            * мы рендерим только их, всё остальное пропускается.\n\n          Такой приём делает производительность почти независимой от общего\n          количества элементов: если в кадре помещается 40 блоков — библиотека\n          нарисует ровно 40, а не десятки тысяч, скрытых за пределами экрана. На\n          дальних масштабах в viewport попадает большое количество элементов,\n          поэтому мы рисуем лёгкие Canvas‑примитивы, а при приближении камеры\n          количество элементов снижается и высвобождённые ресурсы позволяют\n          переключиться на HTML‑режим с полной детализацией.\n\n\n          Сводя всё воедино, получается простая схема:\n\n            * Canvas отвечает за скорость,\n            * HTML — за интерактивность,\n            * R‑Tree и Spatial Culling незаметно объединяют их в единую систему, позволяя быстро понимать какие элементы можно нарисовать на html‑слое.\n\n          Пока камера двигается, маленький viewport спрашивает у R‑Tree лишь те\n          объекты, которые реально находятся в кадре. Такой подход позволяет нам\n          рисовать действительно большие графы, или по крайней мере иметь запас\n          производительности до тех пор, пока пользователь не ограничит\n          viewport.\n\n\n          Итого в своём ядре библиотека содержит:\n\n            * Canvas‑режим с простыми примитивами;\n            * HTML‑режим с полной детализацией;\n            * R‑Tree и Spatial Culling для оптимизации производительности;\n            * привычную событийную модель.\n\n          Но для продакшена этого недостаточно, нужно иметь возможность\n          расширять библиотеку и кастомизировать её под свои нужды.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Кастомизация{#customization}\n\n\n          Библиотека предлагает два взаимодополняющих способа расширения и\n          изменения поведения:\n\n            * Переопределение базовых компонентов. Меняем логику стандартных Block, Anchor, Connection.\n            * Расширение через слои (Layers). Добавляем принципиально новую функциональность поверх/под существующей сцены.\n\n          ### Переопределение компонентов\n\n\n          Когда нужно модифицировать внешний вид или поведение уже существующих\n          элементов, наследуемся от базового класса и переопределяем ключевые\n          методы. Затем регистрируем компонент под собственным именем.\n\n\n          #### Кастомизация блоков\n\n\n          Например, если вам нужно создать граф с прогресс‑барами на блоках —\n          скажем, для отображения статуса выполнения задач в пайплайне — вы\n          можете легко кастомизировать стандартные блоки:\n\n\n          ```json\n\n          import { CanvasBlock } from \"@gravity‑ui/graph\";\n\n\n          class ProgressBlock extends CanvasBlock {\n            // Базовая форма блока с закругленными углами\n            public override renderBody(ctx: CanvasRenderingContext2D): void {\n              ctx.fillStyle = \"#ddd\";\n              ctx.beginPath();\n              ctx.roundRect(this.state.x, this.state.y, this.state.width, this.state.height, 12);\n              ctx.fill();\n              ctx.closePath();\n            }\n\n            public renderSchematicView(ctx: CanvasRenderingContext2D): void {\n              const progress = this.state.meta?.progress || 0;\n\n              // Рисуем основу блока\n              this.renderBody(ctx);\n\n              // Прогресс‑бар с цветовой индикацией\n              const progressWidth = (this.state.width - 20) * (progress / 100);\n              ctx.fillStyle = progress < 50 ? \"#ff6b6b\" : progress < 80 ? \"#feca57\" : \"#48cae4\";\n              ctx.fillRect(this.state.x + 10, this.state.y + this.state.height - 15, progressWidth, 8);\n\n              // Рамка прогресс‑бара\n              ctx.strokeStyle = \"#ddd\";\n              ctx.lineWidth = 1;\n              ctx.strokeRect(this.state.x + 10, this.state.y + this.state.height - 15, this.state.width - 20, 8);\n\n              // Текст с процентами и названием\n              ctx.fillStyle = \"#2d3436\";\n              ctx.font = \"12px Arial\";\n              ctx.textAlign = \"center\";\n              ctx.fillText(`${Math.round(progress)}%`, this.state.x + this.state.width / 2, this.state.y + 20);\n              ctx.fillText(this.state.name, this.state.x + this.state.width / 2, this.state.y + 40);\n            }\n          }\n\n          ```\n\n\n          #### Кастомизация соединений\n\n\n          Аналогично, если вам нужно изменить поведение и внешний вид связей, —\n          например, показать интенсивность потока данных между блоками — вы\n          можете создать кастомное соединение:\n\n\n          ```json\n\n          import { BlockConnection } from \"@gravity-ui/graph\";\n\n\n          class DataFlowConnection extends BlockConnection {\n            public override style(ctx: CanvasRenderingContext2D) {\n              // Получаем данные о потоке из связанных блоков\n              const sourceBlock = this.sourceBlock;\n              const targetBlock = this.targetBlock;\n\n              const sourceProgress = sourceBlock?.state.meta?.progress || 0;\n              const targetProgress = targetBlock?.state.meta?.progress || 0;\n\n              // Вычисляем интенсивность потока на основе прогресса блоков\n              const flowRate = Math.min(sourceProgress, targetProgress);\n              const isActive = flowRate > 10; // Поток активен при прогрессе > 10%\n\n              if (isActive) {\n                // Активный поток -- толстая зеленая линия\n                ctx.strokeStyle = \"#00b894\";\n                ctx.lineWidth = Math.max(2, Math.min(6, flowRate / 20));\n              } else {\n                // Неактивный поток -- пунктирная серая линия\n                ctx.strokeStyle = \"#ddd\";\n                ctx.lineWidth = this.context.camera.getCameraScale();\n                ctx.setLineDash([5, 5]);\n              }\n\n              return { type: \"stroke\" };\n            }\n          }\n\n          ```\n\n\n          #### Использование кастомных компонентов\n\n\n          Регистрируем созданные компоненты в настройках графа:\n\n\n          ```json\n\n          const customGraph = new Graph({\n            blocks: [\n              {\n                id: \"task1\",\n                is: \"progress\",\n                x: 100,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Data Processing\",\n                meta: { progress: 75 },\n              },\n              {\n                id: \"task2\",\n                is: \"progress\",\n                x: 400,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Analysis\",\n                meta: { progress: 30 },\n              },\n              {\n                id: \"task3\",\n                is: \"progress\",\n                x: 700,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Output\",\n                meta: { progress: 5 },\n              },\n            ],\n            connections: [\n              { sourceBlockId: \"task1\", targetBlockId: \"task2\" },\n              { sourceBlockId: \"task2\", targetBlockId: \"task3\" },\n            ],\n            settings: {\n              // Регистрируем кастомные блоки\n              blockComponents: {\n                'progress': ProgressBlock,\n              },\n              // Регистрируем кастомное соединение для всех связей\n              connection: DataFlowConnection,\n              useBezierConnections: true,\n            },\n          });\n\n\n          customGraph.setEntities({\n            blocks: [\n              {\n              is: 'progress',\n              id: '1',\n              name: \"progress block',\n              x: 10, \n              y: 10, \n              width: 10, \n              height: 10,\n              anchors: [],\n              selected: false,\n              }\n            ]\n          })\n\n\n          customGraph.start();\n\n          ```\n\n\n          #### Результат\n\n\n          В результате получается граф, где:\n\n            * блоки показывают текущий прогресс с цветовой индикацией;\n            * соединения визуализируют поток данных: активные потоки — зелёные и толстые, неактивные — серые и пунктирные;\n            * при зуме блоки автоматически переключаются на HTML‑режим с полной интерактивностью.\n\n          ### Расширение слоями\n\n\n          Слои — это дополнительные Canvas или HTML‑элементы, которые\n          вставляются в «пространство» графа. По сути, каждый слой — это\n          отдельный канал рендеринга, который может содержать собственный canvas\n          для быстрой графики или HTML‑контейнер для сложных интерактивных\n          элементов.\n\n\n          Кстати, именно через слои работает React‑интеграция нашей библиотеки:\n          React‑компоненты рендерятся в HTML‑слой через React Portal.\n\n\n          #### Архитектура слоёв\n\n\n          Слои — это еще одно решение ключевое решение дилеммы Canvas vs HTML.\n          Слои синхронизируют позиции Canvas и HTML‑элементов, обеспечивая\n          правильное наложение их друг на друга. Это позволяет бесшовно\n          переключать Canvas и HTML оставаясь в едином пространстве. Граф\n          состоит из независимых слоёв, наложенных друг на друга:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic7.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Слои могут работать в двух системах координат:\n\n            * Привязанные к графу (`transformByCameraPosition: true`):\n\n              * элементы движутся вместе с камерой,\n              * блоки, соединения, элементы графа.\n\n            * Зафиксированные на экране (`transformByCameraPosition: false`):\n\n              * остаются на месте при панорамировании,\n              * тулбары, легенды, контролы UI.\n\n          #### Как устроена React‑интеграция\n\n\n          Слой с React‑интеграцией достаточно показателен для демонстрации, что\n          такое слои. Для начала давайте посмотрим на компонент, выделяющий\n          список блоков, которые находятся в области видимости камеры. Для этого\n          нам нужно подписаться на изменения камеры и после каждого изменения\n          делать проверку пересечения viewport камеры c hitbox элементов.\n\n\n          ```json\n\n          import { Graph } from \"@gravity-ui/graph\";\n\n\n          const BlocksList = ({ graph, renderBlock }: { graph: Graph,\n          renderBlock: (graph: Graph, block: TBlock) => React.JSX.Element }) =>\n          {\n            const [blocks, setBlocks] = useState([]);\n\n            const updateVisibleList = useCallback(() => {\n              const cameraState = graph.cameraService.getCameraState();\n              const CAMERA_VIEWPORT_TRESHOLD = 0.5;\n              const x = -cameraState.relativeX - cameraState.relativeWidth * CAMERA_VIEWPORT_TRESHOLD;\n              const y = -cameraState.relativeY - cameraState.relativeHeight * CAMERA_VIEWPORT_TRESHOLD;\n              const width = -cameraState.relativeX + cameraState.relativeWidth * (1 + CAMERA_VIEWPORT_TRESHOLD) - x;\n              const height = -cameraState.relativeY + cameraState.relativeHeight * (1 + CAMERA_VIEWPORT_TRESHOLD) - y;\n              \n              const blocks = graph\n                .getElementsOverRect(\n                  {\n                    x,\n                    y,\n                    width,\n                    height,\n                  }, // определяет области в которой будет искаться список блоков\n                  [CanvasBlock] // определяет типы элементов, которые будут искаться в области видимости камеры\n                ).map((component) => component.connectedState); // Получаем список моделей блоков\n\n                setBlocks(blocks);\n            });\n\n              useGraphEvent(graph, \"camera-change\", ({ scale }) => {\n                if (scale >= 0.7) {\n                  // Если масштаб больше 0.7, то обновляем список блоков\n                  updateVisibleList()\n                  return;\n                }\n                setBlocks([]);\n              });\n\n              return blocks.map(block => <React.Fragment key={block.id}>{renderBlock(graphObject, block)}</React.Fragment>)\n          }\n\n          ```\n\n\n          Теперь давайте посмотрим на описание самого слоя, который будет\n          использовать этот компонент.\n\n\n          ```json\n\n          import { Layer } from '@gravity-ui/graph';\n\n\n          class ReactLayer extends Layer {\n            constructor(props: TReactLayerProps) {\n              super({\n                html: {\n                  zIndex: 3, // поднимаем слой над остальными слоями\n                  classNames: [\"no-user-select\"], // добавляем класс для отключения выделения текста\n                  transformByCameraPosition: true, // слой привязан к камере - теперь слой будет двигаться вместе с камерой\n                },\n                ...props,\n              });\n            }\n\n            public renderPortal(renderBlock: <T extends TBlock>(block: T) => React.JSX.Element) {\n              if (!this.getHTML()) {\n                return null;\n              }\n\n              const htmlLayer = this.getHTML() as HTMLDivElement;\n\n              return createPortal(\n                React.createElement(BlocksList, {\n                  graph: this.context.graph,\n                  renderBlock: renderBlock,\n                }),\n                htmlLayer,\n              );\n            }\n          }\n\n          ```\n\n\n          Теперь мы можем использовать этот слой в нашем приложении.\n\n\n          ```json\n\n          import { Flex } from \"@gravity-ui/uikit\";\n\n\n          const graph = useMemo(() => new Graph());\n\n          const containerRef = useRef<HTMLDivElement>();\n\n\n          useEffect(() => {\n              if (containerRef.current) {\n                graph.attach(containerRef.current);\n              }\n\n              return () => {\n                graph.detach();\n              };\n            }, [graph, containerRef]);\n\n\n          const reactLayer = useLayer(graph, ReactLayer, {});\n\n\n          const renderBlock = useCallback((graph, block) => <Block graph={graph}\n          block={block}>{block.name}</Block>)\n\n            return (\n              <div>\n                <div style={{ position: \"absolute\", overflow: \"hidden\", width: \"100%\", height: \"100%\" }} ref={containerRef}>\n                  {graph && reactLayer && reactLayer.renderPortal(renderBlock)}\n                </div>\n              </div>\n            );\n          ```\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          В целом всё довольно просто. Ничего из того, что было описано выше, не\n          нужно писать самому — всё уже написано и готово к использованию.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Наша библиотека графов: в чем плюсы и как пользоваться{#library}\n\n\n          Когда мы начинали работу над библиотекой, главным вопросом было: как\n          сделать так, чтобы разработчику не пришлось выбирать между\n          производительностью и удобством разработки? Ответ оказался в\n          автоматизации этого выбора.\n\n\n          ### Преимущества\n\n\n          #### Производительность + удобство\n\n\n          [@gravity‑ui/graph](https://github.com/gravity-ui/graph){target=\"_blank\"}\n          автоматически переключается между Canvas и HTML в зависимости от\n          масштаба. Это означает, что вы получаете:\n\n            * Стабильные 60 FPS на графах из тысяч элементов.\n            * Возможность использовать полноценные HTML‑компоненты с богатой интерактивностью при детальном просмотре.\n            * Единую событийную модель независимо от способа рендеринга — click, mouseenter работают одинаково на Canvas и в HTML.\n\n          #### Совместимость с UI‑библиотеками\n\n\n          Одно из главных преимуществ — совместимость с любыми UI‑библиотеками.\n          Если ваша команда использует:\n\n            * Gravity UI,\n            * Material‑UI,\n            * Ant Design,\n            * кастомные компоненты.\n\n          …, то вам не нужно от них отказываться! При увеличении масштаба граф\n          автоматически переключается в HTML‑режим, где привычные `Button`,\n          `Select`, `DatePicker` в нужной вам цветовой теме работают точно так\n          же, как в обычном React‑приложении.\n\n\n          #### Framework agnostic\n\n\n          Хотя мы и реализовали базовый HTML‑renderer используя React, мы\n          постарались разрабатывать библиотеку так, чтобы библиотека оставалась\n          framework‑agnostic. Это значит при необходимости вы можете довольно\n          просто реализовать слой с интеграцией вашего любимого фреймворка.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## А есть ли аналоги?{#analogs}\\n\\nНа рынке сейчас довольно много решений для отрисовки графов, от платных решений вроде [yFiles](https://yfiles.dev/){target=\\\"_blank\\\"}, [JointJS](https://github.com/clientIO/joint){target=\\\"_blank\\\"}, до опенсорс‑решений [Foblex Flow](https://github.com/Foblex/f-flow){target=\\\"_blank\\\"}, [baklavajs](https://github.com/newcat/baklavajs){target=\\\"_blank\\\"}, [jsPlumb](https://github.com/jsplumb/community-edition){target=\\\"_blank\\\"}. Но мы для сравнения рассматриваем [@antv/g6](https://github.com/antvis/G6){target=\\\"_blank\\\"} и [React Flow](https://github.com/xyflow/xyflow){target=\\\"_blank\\\"} как наиболее популярные инструменты. Каждый из них обладает своими особенностями.\\n\\nReact Flow — хорошая библиотека, заточенная на построение node‑based интерфейсов. У неё есть очень большие возможности, но из‑за использования svg и html — довольно скромная производительность. Библиотека хороша, когда есть уверенность, что графы не будут превышать 100–200 блоков.\\n\\nВ свою очередь у @antv/g6 есть куча возможностей, она поддерживает Canvas и в частности WebGL. Напрямую @antv/g6 и @gravity‑ui/graph, наверное, сравнивать нельзя: ребята больше ориентируются на построения графов и диаграмм, — но node‑based UI тоже поддерживается. Так что antv/g6 подойдёт, если вам важно не только node‑based интерфейс, но и нарисовать графики.\\n\\nХотя библиотека @antv/g6 умеет как в canvas/webgl, так и в html/svg, управление правилами переключения придётся делать руками, и нужно это сделать правильно. По производительности она сильно быстрее, чем React Flow, но к библиотеке всё же есть вопросы. Хотя заявлено, что есть поддержка WebGL, если посмотреть на их [стресс‑тест](https://g6.antv.antgroup.com/en/examples/performance/massive-data#60000){target=\\\"_blank\\\"}, то заметно, что на 60к нодах библиотека не способна обеспечить динамики — на MacBook M3 отрисовка одного кадра заняла 4 секунды. Для сравнения наш [стресс‑тест](https://preview.gravity-ui.com/graph/?path=/story/stories-main-grapheditor--graph-stress-test){target=\\\"_blank\\\"} на 111к нод и 109к связей на том же Macbook M3: рендеринг сцены всего графа занимает ~60ms что даёт ~15–20FPS. Это не очень много, но с учетом Spatial Culling есть возможность ограничить viewport и таким образом улучшить отзывчивость. Хотя мейнтейнеры [заявляли](https://github.com/antvis/G6/issues/1597){target=\\\"_blank\\\"}, что хотят добиться рендеринга 100к нод в 30 FPS, судя по всему, добиться этого им пока не удалось.\\n\\nЕщё один пункт, по которому @gravity‑ui/graph выигрывает, — это размер бандла.\\n\\n#|\\n|||Bundle size Minified|Bundle size Minified + Gzipped||\\n||@antv/g6 [bundlephobia](https://bundlephobia.com/package/@antv/g6@5.0.49){target=\\\"_blank\\\"}|1.1 MB|324.5\\_kB||\\n||react flow [bundlephobia](https://bundlephobia.com/package/@xyflow/react@12.8.1){target=\\\"_blank\\\"}|181.2\\_kB|56.4\\_kB||\\n||@gravity-ui/graph [bundlephobia](https://bundlephobia.com/package/@gravity-ui/graph){target=\\\"_blank\\\"}|2.2\\_kB|672\\_B||\\n|#\\n\\nХотя обе библиотеки довольно мощные по производительности или по удобству интеграции, @gravity‑ui/graph обладает рядом преимуществ — библиотека способна обеспечить производительность на действительно больших графах и сохранить UI/UX для пользователя и упростить разработку.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Планы на будущее{#future}\n\n\n          Уже сейчас библиотека имеет достаточный запас производительности для\n          большинства задач, поэтому в ближайшее время мы больше внимания будем\n          уделять развитию экосистемы вокруг библиотеки — разрабатывать слои\n          (плагины), интеграции для других библиотек и фреймворков\n          (Angular/Vue/Svelte, …etc), добавим поддержку touch‑девайсов,\n          адаптацию для мобильных браузеров и в целом улучшим UX/DX.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Попробуйте и присоединяйтесь{#try}\n\n\n          В [репозитории](https://github.com/gravity-ui/graph){target=\"_blank\"}\n          вы найдёте полностью рабочую библиотеку:\n\n            * Ядро на Canvas + R‑Tree (≈ 30K строк кода),\n            * React‑интеграцию,\n            * Storybook с примерами.\n\n          Установить библиотеку можно в одну строку:\n\n\n          `npm install @gravity-ui/graph`\n\n\n          --------------\n\n\n          Довольно долго библиотека, которая сейчас зовётся @gravity‑ui/graph,\n          была внутренним инструментом внутри Нирваны, и выбранный подход хорошо\n          себя зарекомендовал. Сейчас нам хочется поделиться нашими разработками\n          и помочь разработчикам снаружи рисовать свои графы проще, быстрее и\n          производительнее.\n\n\n          Мы хотим стандартизировать подходы к отображению сложных графов в\n          опенсорс‑сообществе — слишком много команд изобретают велосипед или\n          мучаются с неподходящими инструментами.\n\n\n          Поэтому нам очень важно собрать ваш фидбек — разные проекты приносят\n          разные edge‑случаи, которые позволяют развивать библиотеку. Это\n          поможет нам доработать библиотеку и быстрее растить экосистему Gravity\n          UI.\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
    "title": "",
    "noIndex": false,
    "shareTitle": null,
    "shareDescription": null,
    "shareImage": null,
    "pageLocaleId": null,
    "author": "timofeyevvv",
    "metaDescription": null,
    "keywords": [],
    "shareGenTitle": null,
    "canonicalLink": null,
    "sharingType": "auto",
    "sharingTheme": "light",
    "comment": "initial",
    "shareImageUrl": "https://storage.cloud-preprod.yandex.net/ui-api-ru-preprod-stable-share-generator-screenshots/cache/292d9f3e0a443a096ee408a6f28fc6fec674eb78.png",
    "pageRegionId": 75,
    "summary": null,
    "versionId": 199,
    "service": null,
    "solution": null,
    "locales": [
      {
        "id": 75,
        "pageId": 71,
        "locale": "ru",
        "createdAt": "2026-01-15T11:26:48.440Z",
        "updatedAt": "2026-01-15T11:26:48.519Z",
        "publishedVersionId": null,
        "lastVersionId": 195
      },
      {
        "id": 76,
        "pageId": 71,
        "locale": "en",
        "createdAt": "2026-01-15T11:26:48.532Z",
        "updatedAt": "2026-01-15T11:26:48.609Z",
        "publishedVersionId": null,
        "lastVersionId": 196
      }
    ],
    "pageRegions": [
      {
        "regionCode": "en",
        "publishedVersionId": null
      },
      {
        "regionCode": "ru-ru",
        "publishedVersionId": 199
      }
    ],
    "searchCategory": {
      "id": 7,
      "slug": "blog",
      "title": "Блог",
      "url": "/blog"
    },
    "voiceovers": []
  }
  