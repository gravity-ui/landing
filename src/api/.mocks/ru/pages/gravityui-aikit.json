{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:58:27.903Z",
  "updatedAt": "2026-01-27T13:58:27.903Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "ru-ru",
  "publishedVersionId": 269,
  "lastVersionId": 269,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **Илья Ломтев**\n\n          Frontend‑разработчик\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          В этой статье:\n\n            - [Как и почему мы сделали AIKit](#why)\n            - [Архитектура AIKit: на что мы опирались](#architecture)\n            - [Как собрать свой чат](#how)\n            - [Как AIKit повлиял на сервисы](#influence)\n            - [Что дальше](#further)\n            - [Как попробовать AIKit](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nЗа последний год мы наблюдаем бум ИИ‑помощников, и это не обошло стороной интерфейсы в Yandex\\_Cloud: то в техподдержке завёлся чат‑бот с моделью, то в консоли — агент для рабочих операций. Команды подключали модели, продумывали диалоговую логику, рисовали дизайн и собирали чаты — и делали всё это поодиночке.\\n\\nРазные команды собирали интерфейсы на общем фреймворке Gravity UI, но постепенно там появилось столько вариаций, что стало сложно поддерживать единый пользовательский опыт. Да и коллеги всё чаще сталкивались с тем, что тратят время на одни и те же решения.\\n\\nЧтобы перестать каждый раз изобретать велосипед, мы собрали накопленные практики в единый подход и сделали инструмент для чат‑ботов с ИИ — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}. Он позволяет создать полноценный интерфейс ассистента за несколько дней и при этом легко адаптировать его под разные сценарии.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nМеня зовут Илья Ломтев, я старший разработчик в команде Foundation Services Yandex\\_Cloud, и в статье я расскажу, почему мы решили собрать AIKit, как он устроен, немного о планах на будущее — и о том, что можно попробовать у себя.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Как и почему мы сделали AIKit{#why}\\n\\nЗа последний год в Yandex\\_Cloud выросло число сервисов с ИИ‑ассистентами, например: \\n\\n  * Code Assistant Chat в SourceCraft — ассистент помогает разработчикам писать код, а в режиме ИИ‑агента создаёт и настраивает репозитории, запускает CI/CD‑процессы, отвечает на вопросы по документации и автоматизирует задачи. Также умеет управлять issues, пул‑реквестами, работать с кодом: объяснять, создавать и редактировать файлы.\\n\\n  * ИИ‑ассистент в облачной консоли — ассистент, разработанный для управления ресурсами в Yandex\\_Cloud. Основная задача — помочь быстро и безопасно настраивать, изменять и управлять облачной инфраструктурой, скрывая сложность взаимодействия с API и инструментами.\\n\\nВ экосистеме возник десяток чатов, каждый со своей логикой, своим форматом сообщений и набором корнер‑кейсов. \\n\\nМы обнаружили, что команды приходят к примерно одинаковому набору задач. Что нужно большинству: \\n\\n  * аккуратно отображать сообщения пользователя и ассистента, \\n\\n  * правильно организовать стриминг ответов, \\n\\n  * показывать индикатор «ассистент печатает», \\n\\n  * обрабатывать ошибки вроде оборвавшегося соединения или ретраев. \\n\\nЗадачи по сути одинаковые, а вот путей решения много, и UX отличается. Например, расположение и способ отображения истории чатов: это может быть как отдельный экран, открывающийся как меню, так и список чатов в popup.\\n\\nПроявилась проблема: опыт в разных чатах существенно отличался. Где‑то ассистент стримил ответ, а где‑то показывал сразу готовый текст. В одном интерфейсе сообщения группировались, а в другом — шли сплошной лентой. Это ломало общий UX — получалось, что пользователь переходит между продуктами одной экосистемы, а ощущения от ассистента совершенно разные.   \\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: Примеры чатов, построенных на AIKit, в светлой теме\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Ещё стало заметно, что раскатывать новые фичи в модели становилось всё\n          сложнее. Чтобы донести до пользователей, например, инструментальность,\n          мультимодальность или структурированные ответы тулов, нужно было\n          согласовать контракт, доработать бэкенды, а затем обновить UI в каждой\n          команде отдельно. В таких условиях любые изменения занимали много\n          времени и плохо масштабировались.\n\n\n          Мы захотели остановить этот рост вариативности и вернуть\n          предсказуемость. Для этого требовалось унифицировать модель данных и\n          паттерны работы, дать готовые компоненты и хуки, чтобы командам не\n          приходилось начинать с нуля, и оставить пространство для кастомизации\n          — ведь сценарии у всех разные. \n\n\n          Так мы пришли к идее отдельной библиотеки @gravity‑ui/aikit — это\n          расширение Gravity UI, которое следует тем же принципам, но\n          ориентировано на современные ИИ‑сценарии: диалоги, ассистентов,\n          мультимодальность.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Архитектура AIKit: на что мы опирались{#architecture}\\n\\nПроектируя AIKkit, мы ориентировались на опыт [AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"} и несколько фундаментальных принципов.\\n\\n**Atomic Design в основе**: вся библиотека строится от атомов к страницам. Такая структура даёт чёткую иерархию, позволяет переиспользовать компоненты и при необходимости менять поведение на любом уровне.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**Полностью SDK‑agnostic**: AIKit не зависит от конкретного ИИ‑провайдера. Можно использовать OpenAI, Alice\\_AI LLM или свой бэкенд — UI принимает данные через props, а состояние и запросы остаются на стороне продукта. \\n\\n**Два уровня использования для сложных сценариев**: есть готовый компонент, который работает «из коробки», и есть хук с логикой, который позволяет полностью контролировать UI. Например, можно воспользоваться `PromptInput` или собрать своё поле ввода на базе `usePromptInput`. Это даёт гибкость без необходимости переписывать фундамент.\\n\\n**Расширяемая система типов**. Чтобы обеспечить единообразие и типобезопасность, мы собрали расширяемую модель данных. Сообщения представлены единой типизированной структурой: есть сообщения пользователя, сообщения ассистента и несколько базовых типов контента — текст (`text`), размышления модели (`thinking`), инструменты (`tool`). При этом можно добавлять свои типы через `MessageRendererRegistry`. \\n\\nВсё это типизировано в TypeScript, что помогает быстрее собирать сложные сценарии и избежать ошибок на этапе разработки.\\n\\n```javascript\\n// 1. Определяем тип данных\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. Создаём компонент отображения\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>Визуализация графика: {part.data.chartType}</div>;\\n};\\n// 3. Регистрируем рендерер\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. Используем в AssistantMessage\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\nНаконец мы предусмотрели темизацию через CSS‑переменные, добавили i18n (RU/EN), обеспечили доступность (ARIA, клавиатурная навигация), и настроили визуальные регрессионные тесты через Playwright Component Testing в Docker — и библиотека была готова к продакшн‑использованию.\\n\\n### Что под капотом \\n\\nВ основе AIKit — единая модель диалога. Чтобы её создать, для начала потребовалось разобраться с иерархией сообщений. \\n\\nСообщения сами по себе довольно многогранные сущности. Есть первое сообщение от LLM — это один стрим. Но в рамках него может быть много разных вложенных сообщений: по сути это рассуждения, предложения, вызовы тулов для решения одного вопроса. Все эти разные подсообщения — по факту одно сообщение от бэкенда. Но также каждое из них вполне может быть отдельным сообщением в простом использовании LLM. \\n\\nПоэтому мы оставили возможность использовать чат обоими способами: сообщения могут быть вложены друг в друга, а могут быть плоскими — здесь всё зависит от потребности.\\n\\nУправление состоянием при этом остаётся у сервиса. AIKit не хранит данные сам — он принимает их извне. Команды могут использовать React State, Redux, Zustand, Reatom — всё, что удобно. Мы лишь даём хуки, которые инкапсулируют типовую UI‑логику, например: \\n\\n  * умную прокрутку с помощью `useSmartScroll`;\\n\\n  * работу с датами, к примеру, форматирование дат с учётом локали `useDateFormatter`; \\n\\n  * обработку тул‑сообщений `useToolMessage`;\\n\\n  * и всё остальное, что нужно для построения диалога.\\n\\nВдобавок к этому AIKit остаётся расширяемым. Можно подключать любые модели, создавать собственные типы контента и строить UI полностью под свои задачи — пользуясь логикой из хуков или используя готовые компоненты как базу. Архитектура позволяет экспериментировать, не нарушая общих принципов.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Как собрать свой чат{#how}\n\n\n          Для создания своего первого чата воспользуемся подготовленным\n          компонентом ChatContainer:\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // Your message sending logic\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // Update state\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'Start a conversation by typing a message or selecting a suggestion.',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: 'Try asking:',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: 'Explain quantum computing in simple terms'\n                  },\n                  {\n                    id: '2',\n                    title: 'Write a poem about nature'\n                  },\n                  {\n                    id: '3',\n                    title: 'Help me debug my JavaScript code'\n                  },\n                  {\n                    id: '4',\n                    title: 'Summarize recent AI developments'\n                  }\n                ],\n                title: 'Welcome to AI Chat'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          «Из коробки» всё выглядит вот так:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Добавим немного праздника: \n\n\n          1. Поправим начальное состояние. \n\n              Для более тонкой настройки соберём чат из отдельных компонентов: `Header`, `MessageList`, `PromptBox`.\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AI Assistant\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"Спросите что угодно...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. Применим разные встроенные типы сообщений, импортированные через\n          `MessageType`.\n\n              * `thinking` — покажет процесс размышления ИИ (так пользователь может изучить логику, по которой ассистент готовит ответ).\n\n              * `tool` — подойдёт для отображения интерактивных блоков ответа, в нашем случае, это блок с кодом, в котором корректно работает подсветка синтаксиса, поддержаны операции редактирования и копирования в буфер обмена.\n\n              Также можно добавлять собственные типы, например, сообщения с изображениями:\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. Добавим стилизацию через CSS…\n\n              …и получим чат с Дедом Морозом:)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          Для полной кастомизации отдельных элементов можно использовать хуки —\n          будем рады увидеть ваши варианты стилизации в комментариях под\n          статьёй!\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Как AIKit повлиял на сервисы{#influence}\\n\\nРезультат использования AIKit в Yandex\\_Cloud стал заметен быстро. Во всех сервисах ассистенты стали вести себя одинаково: одинаково стримить ответы, одинаково показывать ошибки, одинаково группировать сообщения. UX стал единообразным, теперь с ним проще взаимодействовать во всей экосистеме, поведение более ожидаемое и предсказуемое.\\n\\n  * UX‑язык стал единым — чаты ассистентов в разных продуктах теперь ощущаются как часть одной экосистемы. Пользователи видят предсказуемое поведение: одинаковый стриминг, обработку ошибок, паттерны взаимодействия. \\n\\n  * Скорость разработки UI чата гораздо выше. \\n\\n  * Централизованное развитие — новые фичи вроде типа контента thinking или улучшенной работы с тулами добавляются один раз и автоматически доступны всем. \\n\\n  * Библиотека стала основой для формирования стандартов ИИ‑интерфейсов в экосистеме.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Что дальше{#further}\n\n\n          Теперь о планах. Мы выделили несколько направлений: \n\n            * Улучшение производительности через виртуализацию для работы с очень большими историями чатов. \n\n            * Расширение базовых сценариев под новые возможности ИИ‑агентов, которые активно развиваются. \n\n            * Добавление утилит, чтобы упростить маппинг данных популярных ИИ‑моделей в нашу модель данных чата. \n\n          Дополнительно будем развивать документацию и примеры. И, конечно,\n          развитие сообщества — хотим, чтобы библиотека была полезна не только\n          внутри компании, но и внешним разработчикам.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Как попробовать AIKit{#try}\n\n\n          Переходите в [раздел\n          библиотеки](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}\n          на нашем сайте. Если вы делаете собственный ИИ‑ассистент, хотите\n          быстрый и предсказуемый чат‑интерфейс и уже используете Gravity UI\n          (или готовы попробовать), загляните в README и примеры. И ещё будем\n          благодарны за обратную связь — заводите issue, присылайте PR,\n          рассказывайте, что ещё нужно для ваших сценариев!\n\n\n          Если Вам нравится наш проект, будем рады ⭐️ в\n          [AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"} и\n          [UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"}!\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "add sharing",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 116,
  "summary": null,
  "versionId": 269,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "ru",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "en",
      "publishedVersionId": 268
    },
    {
      "regionCode": "ru-ru",
      "publishedVersionId": 269
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "Блог",
    "url": "/blog"
  },
  "voiceovers": []
}