{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:58:27.903Z",
  "updatedAt": "2026-01-27T13:58:27.903Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "pt-br",
  "publishedVersionId": 269,
  "lastVersionId": 269,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **Илья Ломтев**\n\n          Desenvolvedor frontend\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          Neste artigo:\n\n            - [Como e por que criamos o AIKit](#why)\n            - [Arquitetura do AIKit: no que nos baseamos](#architecture)\n            - [Como montar seu próprio chat](#how)\n            - [Como o AIKit impactou os serviços](#influence)\n            - [O que vem depois](#further)\n            - [Como experimentar o AIKit](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nNo último ano, vimos um boom de assistentes de IA, e isso também afetou as interfaces no Yandex\\_Cloud: ora aparece um chat-bot com modelo no suporte, ora um agente para operações do dia a dia no console. As equipes conectavam modelos, pensavam na lógica de diálogo, desenhavam o design e montavam chats — e faziam tudo isso separadamente.\\n\\nEquipes diferentes montavam interfaces no framework comum Gravity UI, mas aos poucos surgiram tantas variações que ficou difícil manter uma experiência de usuário unificada. E os colegas passaram a enfrentar cada vez mais a situação de gastar tempo nas mesmas soluções, repetidamente.\\n\\nPara parar de reinventar a roda toda vez, reunimos as práticas acumuladas em uma abordagem única e criamos uma ferramenta para chat-bots com IA — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}. Ela permite criar uma interface completa de assistente em poucos dias e, ao mesmo tempo, adaptá-la facilmente a diferentes cenários.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nMeu nome é Ilya Lomtev, sou desenvolvedor sênior na equipe Foundation Services do Yandex\\_Cloud, e neste artigo vou contar por que decidimos criar o AIKit, como ele é estruturado, um pouco sobre os planos para o futuro — e o que você pode experimentar por conta própria.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Como e por que criamos o AIKit{#why}\\n\\nNo último ano, cresceu o número de serviços no Yandex\\_Cloud com assistentes de IA, por exemplo: \\n\\n  * Code Assistant Chat no SourceCraft — o assistente ajuda desenvolvedores a escrever código e, no modo de agente de IA, cria e configura repositórios, executa processos de CI/CD, responde perguntas sobre a documentação e automatiza tarefas. Também sabe gerenciar issues, pull requests e trabalhar com código: explicar, criar e editar arquivos.\\n\\n  * Assistente de IA no console da nuvem — um assistente desenvolvido para gerenciar recursos no Yandex\\_Cloud. A principal tarefa é ajudar a configurar, alterar e administrar a infraestrutura de nuvem de forma rápida e segura, ocultando a complexidade da interação com APIs e ferramentas.\\n\\nNo ecossistema, surgiram cerca de uma dezena de chats, cada um com sua lógica, seu formato de mensagens e seu conjunto de casos de borda. \\n\\nDescobrimos que as equipes chegam a um conjunto de tarefas mais ou menos igual. O que a maioria precisa: \\n\\n  * exibir com cuidado as mensagens do usuário e do assistente; \\n\\n  * organizar corretamente o streaming das respostas; \\n\\n  * mostrar o indicador «o assistente está digitando»; \\n\\n  * tratar erros como conexão interrompida ou retries. \\n\\nAs tarefas, na prática, são as mesmas, mas existem muitos caminhos de solução — e o UX varia. Por exemplo, a posição e a forma de exibir o histórico de chats: pode ser tanto uma tela separada que abre como um menu, quanto uma lista de chats em um popup.\\n\\nO problema ficou evidente: a experiência nos diferentes chats variava muito. Em um lugar o assistente fazia streaming da resposta, e em outro mostrava imediatamente o texto pronto. Em uma interface as mensagens eram agrupadas, e em outra vinham em uma única linha do tempo contínua. Isso quebrava o UX geral — no fim, o usuário alternava entre produtos de um mesmo ecossistema, mas a sensação do assistente era completamente diferente.   \\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: Exemplos de chats construídos com o AIKit, no tema claro\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Também ficou claro que lançar novas funcionalidades nas models estava ficando\n          cada vez mais difícil. Para levar aos usuários, por exemplo, o uso de ferramentas,\n          multimodalidade ou respostas estruturadas de tools, era preciso\n          alinhar um contrato, evoluir os backends e depois atualizar o UI em cada\n          equipe separadamente. Nessas condições, qualquer mudança levava muito\n          tempo e não escalava bem.\n\n\n          Queríamos parar esse crescimento de variabilidade e recuperar\n          previsibilidade. Para isso, era necessário unificar o modelo de dados e\n          os padrões de trabalho, entregar componentes e hooks prontos para que as equipes não\n          precisassem começar do zero, e deixar espaço para customização\n          — afinal, os cenários são diferentes para cada um. \n\n\n          Assim chegamos à ideia de uma biblioteca separada @gravity‑ui/aikit — uma\n          extensão do Gravity UI que segue os mesmos princípios, mas\n          é orientada a cenários modernos de IA: diálogos, assistentes,\n          multimodalidade.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Arquitetura do AIKit: no que nos baseamos{#architecture}\\n\\nAo projetar o AIKkit, nos orientamos pela experiência do [AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"} e por alguns princípios fundamentais.\\n\\n**Atomic Design como base**: toda a biblioteca é construída de átomos até páginas. Essa estrutura dá uma hierarquia clara, permite reutilizar componentes e, se necessário, mudar o comportamento em qualquer nível.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**Totalmente agnóstico de SDK**: o AIKit não depende de um provedor de IA específico. Você pode usar OpenAI, Alice\\_AI LLM ou seu próprio backend — o UI recebe os dados via props, e o estado e as requisições ficam do lado do produto. \\n\\n**Dois níveis de uso para cenários complexos**: há um componente pronto que funciona “out of the box”, e há um hook com a lógica que permite controlar totalmente o UI. Por exemplo, você pode usar `PromptInput` ou montar seu próprio campo de entrada com base em `usePromptInput`. Isso dá flexibilidade sem precisar reescrever os fundamentos.\\n\\n**Sistema de tipos extensível**. Para garantir consistência e type safety, montamos um modelo de dados extensível. As mensagens são representadas por uma estrutura única e tipada: há mensagens do usuário, mensagens do assistente e vários tipos base de conteúdo — texto (`text`), raciocínio do modelo (`thinking`), ferramentas (`tool`). Ao mesmo tempo, é possível adicionar seus próprios tipos via `MessageRendererRegistry`. \\n\\nTudo isso é tipado em TypeScript, o que ajuda a montar cenários complexos mais rapidamente e evitar erros na fase de desenvolvimento.\\n\\n```javascript\\n// 1. Definimos o tipo de dados\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. Criamos o componente de renderização\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>Visualização do gráfico: {part.data.chartType}</div>;\\n};\\n// 3. Registramos o renderer\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. Usamos em AssistantMessage\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\nPor fim, previmos tematização via variáveis CSS, adicionamos i18n (RU/EN), garantimos acessibilidade (ARIA, navegação por teclado) e configuramos testes de regressão visual via Playwright Component Testing em Docker — e a biblioteca ficou pronta para uso em produção.\\n\\n### O que tem por baixo do capô\\n\\nNo coração do AIKit está um modelo de diálogo unificado. Para criá-lo, primeiro foi preciso entender a hierarquia das mensagens. \\n\\nAs mensagens, por si só, são entidades bastante multifacetadas. Há a primeira mensagem do LLM — isso é um stream. Mas dentro dela pode haver muitas mensagens aninhadas diferentes: na prática, são raciocínios, sugestões, chamadas de tools para resolver uma questão. Todas essas submensagens diferentes são, de fato, uma única mensagem do backend. Mas ao mesmo tempo cada uma delas pode perfeitamente ser uma mensagem separada em um uso mais simples do LLM. \\n\\nPor isso, mantivemos a possibilidade de usar o chat dos dois jeitos: as mensagens podem ser aninhadas umas nas outras ou podem ser planas — aqui tudo depende da necessidade.\\n\\nO gerenciamento de estado permanece com o serviço. O AIKit não armazena dados por conta própria — ele os recebe de fora. As equipes podem usar React State, Redux, Zustand, Reatom — o que for mais conveniente. Nós apenas fornecemos hooks que encapsulam a lógica típica de UI, por exemplo: \\n\\n  * rolagem inteligente com `useSmartScroll`;\\n\\n  * trabalho com datas, por exemplo, formatação de datas com base na localidade via `useDateFormatter`; \\n\\n  * tratamento de mensagens de tool com `useToolMessage`;\\n\\n  * e todo o resto necessário para construir um diálogo.\\n\\nAlém disso, o AIKit permanece extensível. Dá para conectar quaisquer modelos, criar tipos de conteúdo próprios e construir o UI completamente para suas necessidades — usando a lógica dos hooks ou usando componentes prontos como base. A arquitetura permite experimentar sem violar os princípios gerais.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Como montar seu próprio chat{#how}\n\n\n          Para criar seu primeiro chat, vamos usar o componente\n          preparado ChatContainer:\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // Sua lógica de envio de mensagens\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // Atualizamos o estado\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'Start a conversation by typing a message or selecting a suggestion.',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: 'Try asking:',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: 'Explain quantum computing in simple terms'\n                  },\n                  {\n                    id: '2',\n                    title: 'Write a poem about nature'\n                  },\n                  {\n                    id: '3',\n                    title: 'Help me debug my JavaScript code'\n                  },\n                  {\n                    id: '4',\n                    title: 'Summarize recent AI developments'\n                  }\n                ],\n                title: 'Welcome to AI Chat'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          “Out of the box”, tudo fica assim:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Vamos adicionar um pouco de clima festivo: \n\n\n          1. Ajustamos o estado inicial. \n\n              Para uma configuração mais fina, vamos montar o chat a partir de componentes separados: `Header`, `MessageList`, `PromptBox`.\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AI Assistant\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"Pergunte qualquer coisa...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. Aplicamos diferentes tipos de mensagens встроенные, importadas via\n          `MessageType`.\n\n              * `thinking` — mostra o processo de raciocínio da IA (assim o usuário pode entender a lógica com que o assistente prepara a resposta).\n\n              * `tool` — serve para exibir blocos interativos da resposta; no nosso caso, é um bloco de código em que a sintaxe funciona corretamente, e são suportadas operações de edição e cópia para a área de transferência.\n\n              Também é possível adicionar tipos próprios, por exemplo, mensagens com imagens:\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. Adicionamos estilização via CSS…\n\n              …e obtemos um chat com o Papai Noel:)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          Para customização completa de elementos individuais, é possível usar hooks —\n          vamos gostar de ver suas variações de estilização nos comentários\n          do artigo!\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Como o AIKit impactou os serviços{#influence}\\n\\nO resultado do uso do AIKit no Yandex\\_Cloud ficou evidente rapidamente. Em todos os serviços, os assistentes passaram a se comportar da mesma forma: fazer streaming das respostas do mesmo jeito, exibir erros do mesmo jeito, agrupar mensagens do mesmo jeito. O UX ficou uniforme; agora é mais fácil interagir com ele em todo o ecossistema, o comportamento é mais esperado e previsível.\\n\\n  * A linguagem de UX ficou unificada — os chats de assistentes em diferentes produtos agora são percebidos como parte de um único ecossistema. Os usuários veem um comportamento previsível: o mesmo streaming, tratamento de erros e padrões de interação. \\n\\n  * A velocidade de desenvolvimento do UI do chat é muito maior. \\n\\n  * Evolução centralizada — novas funcionalidades, como o tipo de conteúdo thinking ou melhorias no trabalho com tools, são adicionadas uma vez e ficam automaticamente disponíveis para todos. \\n\\n  * A biblioteca virou a base para formar padrões de interfaces de IA no ecossistema.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## O que vem depois{#further}\n\n\n          Agora, sobre os planos. Destacamos algumas frentes: \n\n            * Melhorar a performance via virtualização para trabalhar com históricos de chat muito grandes. \n\n            * Ampliar cenários base para novas capacidades de agentes de IA, que estão evoluindo ativamente. \n\n            * Adicionar utilitários para simplificar o mapeamento de dados de modelos de IA populares para o nosso modelo de dados de chat. \n\n          Além disso, vamos evoluir a documentação e os exemplos. E, claro,\n          o desenvolvimento da comunidade — queremos que a biblioteca seja útil não só\n          dentro da empresa, mas também para desenvolvedores externos.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Como experimentar o AIKit{#try}\n\n\n          Vá para a [seção\n          da biblioteca](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}\n          no nosso site. Se você está criando seu próprio assistente de IA, quer\n          um chat com interface rápida e previsível e já usa o Gravity UI\n          (ou está disposto a experimentar), confira o README e os exemplos. E também\n          vamos agradecer pelo feedback — abra issues, envie PRs,\n          conte o que ainda falta para os seus cenários!\n\n\n          Se você gosta do nosso projeto, vamos agradecer por uma ⭐️ no\n          [AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"} e no\n          [UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"}!\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "add sharing",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 116,
  "summary": null,
  "versionId": 269,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "pt",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "en",
      "publishedVersionId": 268
    },
    {
      "regionCode": "pt-br",
      "publishedVersionId": 269
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "Blog",
    "url": "/blog"
  },
  "voiceovers": []
}