{
    "id": 71,
    "name": "blog/graph",
    "createdAt": "2026-01-15T13:00:46.903Z",
    "updatedAt": "2026-01-15T13:00:46.903Z",
    "type": "default",
    "isDeleted": false,
    "versionOnTranslationId": null,
    "searchCategorySlug": "blog",
    "regions": [],
    "pageId": 71,
    "regionCode": "en",
    "publishedVersionId": 216,
    "lastVersionId": 216,
    "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#CCDAFF'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/speaker.jpg\n          =80x)\n\n\n          **Andreï Chtchetinine**\n\n          Développeur senior d’interfaces\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          Dans cet article :\n\n            - [D’où vient le besoin](#task)\n            - [Comment nous sommes arrivés à la solution](#solution)\n            - [Personnalisation](#customization)\n            - [Notre bibliothèque de graphes : avantages et utilisation](#library)\n            - [Existe-t-il des alternatives ?](#analogs)\n            - [Plans pour l’avenir](#future)\n            - [Essayez et rejoignez-nous](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Bonjour ! Je m’appelle Andreï et je suis développeur d’interfaces dans l’équipe User\n          Experience des services d’infrastructure de Yandex. Nous développons Gravity UI\n          — un design system open source et une bibliothèque de composants React, utilisés\n          par des dizaines de produits au sein de l’entreprise et au-delà.\n          Aujourd’hui, je vais raconter comment nous avons été confrontés à la visualisation\n          de graphes complexes, pourquoi les solutions existantes ne nous convenaient pas,\n          et comment @gravity‑ui/graph est finalement née — une bibliothèque que nous avons\n          décidé d’ouvrir à la communauté.\n\n\n          Cette histoire a commencé par un problème très concret : nous devions rendre\n          des graphes de plus de 10 000 éléments avec des composants interactifs. Chez Yandex,\n          il existe de nombreux projets où les utilisateurs construisent des pipelines complexes\n          de traitement de données — des simples processus ETL jusqu’au machine learning.\n          Quand ces pipelines sont générés de manière programmatique, le nombre de blocs peut\n          atteindre des dizaines de milliers.\n\n\n          Les solutions existantes ne nous satisfaisaient pas :\n\n            * **Les bibliothèques HTML/SVG** sont belles et agréables à développer, mais commencent à ralentir dès quelques centaines d’éléments.\n            * **Les solutions Canvas** tiennent la performance, mais exigent énormément de code pour construire des éléments UI complexes.\n\n          Dessiner un bouton aux coins arrondis avec un dégradé dans Canvas\n          n’est pas difficile. Les problèmes apparaissent lorsqu’il faut créer des contrôles\n          complexes ou une mise en page — il faut écrire des dizaines de lignes\n          de commandes de dessin bas niveau. Chaque élément d’interface doit être\n          programmé de zéro — de la gestion des clics aux animations. Or, nous avions besoin\n          de composants UI complets : boutons, selects, champs de saisie, drag-and-drop.\n\n\n          Nous avons décidé de ne pas choisir entre Canvas et HTML, mais d’utiliser le meilleur\n          des deux technologies. L’idée était simple : basculer automatiquement entre les modes\n          selon le niveau de zoom de l’utilisateur sur le graphe.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: |\n\n          #### Essayez par vous-même\n\n            * [Dépôt GitHub](https://github.com/gravity-ui/graph){target=\"_blank\"}\n            * [Storybook avec des exemples](https://preview.gravity-ui.com/graph/){target=\"_blank\"}\n            * [Playground](https://gravity-ui.com/ru/libraries/graph/playground){target=\"_blank\"}\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## D’où vient le besoin{#task}\n\n\n          ### Nirvana et ses graphes\n\n\n          Chez Yandex, nous avons le service Nirvana pour créer et exécuter des graphes\n          de traitement de données (nous en\n          [avions parlé](https://habr.com/ru/companies/yandex/articles/351016/){target=\"_blank\"}\n          dès 2018). C’est un service grand, populaire, qui existe depuis longtemps.\n\n\n          Une partie des utilisateurs crée les graphes à la main — à la souris, en ajoutant\n          des blocs et en les reliant. Avec ces graphes, pas de souci : il y a peu de blocs\n          et tout fonctionne parfaitement. Mais il existe des projets qui génèrent les graphes\n          automatiquement. Et là, les difficultés commencent : ils peuvent mettre jusqu’à\n          10 000 opérations dans un seul graphe. Cela donne quelque chose comme ça :\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          {% cut \"Et aussi comme ça :\" %}\n\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-1.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-2.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-3.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-4.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-5.png\n          =830x)\n\n\n          {% endcut %}\n\n\n          De tels graphes, une simple combinaison HTML + SVG ne les supporte pas.\n          Le navigateur commence à ramer, la mémoire fuit, l’utilisateur souffre.\n          Nous avons tenté une approche frontale : optimiser le rendu HTML, mais tôt ou tard\n          nous butions sur des limites physiques — le DOM n’est tout simplement pas conçu\n          pour des milliers d’éléments interactifs flottants visibles simultanément.\n\n\n          Il fallait une autre solution, et dans le navigateur il ne nous restait que Canvas.\n          Lui seul peut fournir la performance nécessaire.\n\n\n          Première idée : trouver une solution prête à l’emploi. Nous étions en 2017–2018,\n          et nous avons passé au crible des bibliothèques populaires pour Canvas ou le rendu de graphes,\n          mais toutes se heurtaient au même problème : soit Canvas avec des éléments primitifs,\n          soit HTML/SVG en sacrifiant les performances.\n\n\n          Et si on ne choisissait pas ?\n\n\n          ### Level of Details : inspiration du GameDev\n\n\n          Dans le GameDev et la cartographie, il existe un concept très efficace : Level of Details\n          (LOD). Cette technique est née d’une nécessité : comment afficher un monde immense\n          sans tuer les performances ?\n\n\n          Le principe est simple : un même objet peut avoir plusieurs niveaux de détail\n          selon la distance d’observation. Dans les jeux, c’est particulièrement visible :\n\n            * Au loin, on voit des montagnes — des polygones simples avec une texture de base.\n            * En s’approchant, des détails apparaissent : herbe, rochers, ombres.\n            * Encore plus près, on distingue des feuilles individuelles sur les arbres.\n\n          Personne ne rend des millions de polygones d’herbe quand le joueur est au sommet\n          d’une montagne et regarde au loin.\n\n\n          Sur les cartes, le principe est le même — à chaque niveau de zoom correspond\n          un jeu de données et un niveau de détail :\n\n            * À l’échelle d’un continent — seules les frontières des pays.\n            * En zoomant sur une ville — rues et quartiers apparaissent.\n            * Encore plus près — numéros, cafés, arrêts de bus.\n\n          Nous avons compris : l’utilisateur n’a pas besoin de boutons interactifs\n          à grande échelle sur un graphe de 10 000 blocs — il ne les verra pas\n          et ne pourra pas interagir avec eux.\n\n\n          De plus, tenter de rendre 10 000 éléments HTML simultanément figera le navigateur.\n          Mais quand il zoome sur une zone précise, le nombre de blocs visibles chute fortement —\n          de 10 000 à, disons, 50. C’est précisément là que des ressources se libèrent\n          pour des composants HTML riches en interactivité.\n\n\n          ### Trois niveaux dans notre schéma Level of Details\n\n\n          #### Minimalistic (zoom 0,1–0,3) — Canvas avec des primitives simples\n\n\n          Dans ce mode, l’utilisateur voit l’architecture globale du système : où se trouvent\n          les principaux groupes de blocs et comment ils sont reliés. Chaque bloc est\n          un simple rectangle avec un codage couleur de base. Aucun texte, bouton ou icône détaillée.\n          En revanche, on peut rendre confortablement des milliers d’éléments.\n          À ce niveau, l’utilisateur choisit la zone à étudier en détail.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Schematic (zoom 0,3–0,7) — Canvas avec des détails\n\n\n          Les noms des blocs, des icônes d’état et des ancres de connexion apparaissent.\n          Le texte est rendu via l’API Canvas — c’est rapide, mais les possibilités de style sont limitées.\n          Les liens entre les blocs deviennent plus informatifs : on peut montrer la direction\n          du flux de données, le statut de la connexion. C’est un mode de transition où la performance\n          de Canvas se combine à une information de base.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic4.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Detailed (zoom 0,7+) — HTML avec interactivité complète\n\n\n          Ici, les blocs se transforment en véritables composants d’interface :\n          avec des boutons de contrôle, des champs de paramètres, des barres de progression,\n          des selects. On peut utiliser tout ce que permet HTML/CSS et intégrer des bibliothèques UI.\n          Dans ce mode, le viewport contient généralement au plus 20–50 blocs —\n          idéal pour un travail détaillé.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic5.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          **Et si on utilisait le FPS pour choisir le niveau de détail ?**\n\n\n          Nous avons envisagé des approches où le niveau de détail dépendait du FPS.\n          Mais nous avons constaté que cela rend le système instable : quand les performances\n          augmentent, le système passe à un mode plus détaillé, ce qui baisse le FPS et peut provoquer\n          un retour en arrière — et ainsi de suite en boucle.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Comment nous sommes arrivés à la solution{#solution}\n\n\n          D’accord, le LOD, c’est excellent. Mais l’implémentation nécessite Canvas pour la performance,\n          et c’est un nouveau casse-tête. Dessiner sur Canvas n’est pas très difficile —\n          les problèmes apparaissent quand il faut de l’interactivité.\n\n\n          ### Problème : comment savoir où l’utilisateur a cliqué ?\n\n\n          En HTML, tout est simple : vous cliquez sur un bouton — l’événement arrive directement sur l’élément.\n          Avec Canvas, c’est plus compliqué : vous cliquez sur le canvas — et ensuite ?\n          Il faut déterminer soi-même sur quel élément l’utilisateur a cliqué.\n\n\n          Il existe essentiellement trois approches :\n\n            * Pixel Testing (color picking),\n            * Approche géométrique (parcours naïf de tous les éléments),\n            * Spatial Indexing (index spatial).\n\n          #### Pixel Testing (color picking)\n\n\n          L’idée est simple : on crée un deuxième canvas invisible, on y copie la scène,\n          mais on remplit chaque élément avec une couleur unique qui servira d’ID.\n          Au clic, on lit la couleur du pixel sous le pointeur via getImageData\n          et on obtient l’ID de l’élément.\n\n\n          #|\n\n          ||**Avantages**|**Inconvénients**||\n\n          ||* S’implémente en quelques dizaines de lignes\n\n\n          * Ne nécessite pas de structures de données supplémentaires|* L’anti‑aliasing Canvas mélange les couleurs — un clic sur le bord peut donner un ID « invalide »\n\n\n          * Désactiver l’anti‑aliasing en 2D‑Canvas n’est pas possible\n\n\n          * Le second canvas duplique la mémoire et double le passe de rendu||\n\n          |#\n\n\n          Pour des petites scènes, la méthode convient, mais avec 10 000+ éléments,\n          le taux d’erreur devient inacceptable — on met Pixel Testing de côté.\n\n\n          #### Approche géométrique (parcours naïf de tous les éléments)\n\n\n          L’idée est simple : on parcourt tous les éléments et on vérifie si le point du clic\n          se trouve à l’intérieur de l’élément.\n\n\n          #|\n\n          ||**Avantages**|**Inconvénients**||\n\n          ||* S’implémente en quelques dizaines de lignes\n\n\n          * Ne nécessite pas de structures de données supplémentaires|* Très lent avec un grand nombre d’éléments\n\n\n          * Ne convient pas aux grandes scènes||\n\n          |#\n\n\n          #### Spatial Indexing\n\n\n          Une évolution de l’approche géométrique. Dans l’approche géométrique, on butait sur\n          le nombre d’éléments. Les algorithmes d’index spatial tentent de regrouper des éléments proches,\n          principalement via des arbres, ce qui permet de réduire la complexité à log n.\n\n\n          Il existe de nombreux algorithmes d’index spatial ; nous avons choisi la structure R‑Tree\n          via la bibliothèque\n          [rbush](https://github.com/mourner/rbush){target=\"_blank\"}.\n\n\n          Un R‑Tree est, comme son nom l’indique, un arbre où chaque objet est placé dans un rectangle\n          minimal (MBR), puis ces rectangles sont regroupés en rectangles plus grands.\n          On obtient ainsi un arbre où chaque rectangle contient d’autres rectangles.\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: >-\n          Image de Wikipédia\n          [R‑tree](https://en.wikipedia.org/wiki/R-tree){target=\"_blank\"}\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic6.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Pour chercher dans un RTree, il faut descendre dans l’arbre (en profondeur du rectangle)\n          jusqu’à atteindre l’élément précis. Le chemin est choisi en testant l’intersection du rectangle\n          de recherche avec les MBR. Toutes les branches dont la bounding‑box ne touche même pas\n          le rectangle de recherche sont éliminées immédiatement — c’est pourquoi la profondeur\n          de parcours est généralement limitée à 3–5 niveaux, et la recherche prend des microsecondes\n          même avec des dizaines de milliers d’éléments.\n\n\n          Cette variante est un peu plus lente (O(log n) dans le meilleur cas et O(n) dans le pire)\n          que le pixel testing, mais elle est plus précise et moins gourmande en mémoire.\n\n\n          #### Modèle d’événements\n\n\n          À partir du RTree, on peut construire notre modèle d’événements.\n          Quand l’utilisateur clique, on lance un hit test : on forme un rectangle 1×1 pixel\n          aux coordonnées du curseur et on cherche son intersection dans le R‑Tree.\n          Une fois l’élément trouvé, on lui délègue l’événement. Si l’élément ne stoppe pas\n          l’événement, celui-ci est transmis à son parent, et ainsi de suite jusqu’à la racine.\n          Le comportement est proche du modèle d’événements du navigateur.\n          Les événements peuvent être interceptés, prevent (preventDefault) ou arrêter la propagation.\n\n\n          Comme je l’ai mentionné, lors du hit test nous formons un rectangle 1×1 pixel,\n          ce qui signifie que nous pouvons former un rectangle de n’importe quelle taille.\n          Cela nous aidera à réaliser une autre optimisation très importante — le Spatial Culling.\n\n\n          ### Spatial Culling\n\n\n          Le Spatial Culling est une technique d’optimisation du rendu visant à ne pas dessiner\n          ce qui n’est pas visible. Par exemple, ne pas dessiner des objets hors du champ de la caméra\n          ou masqués par d’autres éléments. Comme notre graphe est rendu en 2D,\n          il suffit de ne pas dessiner les objets situés en dehors du viewport.\n\n\n          Fonctionnement :\n\n            * à chaque déplacement ou zoom de la caméra, on forme un rectangle égal au viewport courant ;\n            * on cherche son intersection dans le R‑Tree ;\n            * on obtient la liste des éléments réellement visibles ;\n            * on ne rend que ceux-ci, le reste est ignoré.\n\n          Cette technique rend la performance presque indépendante du nombre total d’éléments :\n          si 40 blocs tiennent dans le cadre, la bibliothèque dessinera exactement 40, et non\n          des dizaines de milliers hors écran. À grande échelle, beaucoup d’éléments tombent dans le viewport,\n          donc on dessine des primitives Canvas légères ; en zoomant, le nombre d’éléments diminue,\n          et les ressources libérées permettent de basculer en mode HTML avec un niveau de détail complet.\n\n\n          En rassemblant tout, on obtient un schéma simple :\n\n            * Canvas assure la vitesse,\n            * HTML — l’interactivité,\n            * R‑Tree et Spatial Culling les unifient discrètement en un seul système, permettant de déterminer rapidement quels éléments peuvent être dessinés sur la couche HTML.\n\n          Tant que la caméra bouge, le petit viewport ne demande au R‑Tree que les objets réellement\n          présents à l’écran. Cette approche nous permet de dessiner des graphes vraiment grands,\n          ou au moins de conserver une marge de performance tant que l’utilisateur n’a pas restreint\n          le viewport.\n\n\n          Au final, le cœur de la bibliothèque contient :\n\n            * un mode Canvas avec des primitives simples ;\n            * un mode HTML avec un détail complet ;\n            * R‑Tree et Spatial Culling pour optimiser les performances ;\n            * un modèle d’événements familier.\n\n          Mais pour de la production, ce n’est pas suffisant : il faut pouvoir étendre la bibliothèque\n          et la personnaliser selon ses besoins.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Personnalisation{#customization}\n\n\n          La bibliothèque propose deux moyens complémentaires d’extension et de modification du comportement :\n\n            * Redéfinition des composants de base. On change la logique des Block, Anchor et Connection standards.\n            * Extension via des couches (Layers). On ajoute des fonctionnalités fondamentalement nouvelles au-dessus/en dessous de la scène existante.\n\n          ### Redéfinition des composants\n\n\n          Lorsque vous devez modifier l’apparence ou le comportement d’éléments existants,\n          vous héritez de la classe de base et redéfinissez les méthodes clés.\n          Ensuite, vous enregistrez le composant sous votre propre nom.\n\n\n          #### Personnalisation des blocs\n\n\n          Par exemple, si vous devez créer un graphe avec des barres de progression sur les blocs —\n          pour afficher l’état d’exécution des tâches dans un pipeline — vous pouvez facilement\n          personnaliser les blocs standards :\n\n\n          ```json\n\n          import { CanvasBlock } from \"@gravity‑ui/graph\";\n\n\n          class ProgressBlock extends CanvasBlock {\n            // Forme de base du bloc avec coins arrondis\n            public override renderBody(ctx: CanvasRenderingContext2D): void {\n              ctx.fillStyle = \"#ddd\";\n              ctx.beginPath();\n              ctx.roundRect(this.state.x, this.state.y, this.state.width, this.state.height, 12);\n              ctx.fill();\n              ctx.closePath();\n            }\n\n            public renderSchematicView(ctx: CanvasRenderingContext2D): void {\n              const progress = this.state.meta?.progress || 0;\n\n              // Dessiner la base du bloc\n              this.renderBody(ctx);\n\n              // Barre de progression avec indication couleur\n              const progressWidth = (this.state.width - 20) * (progress / 100);\n              ctx.fillStyle = progress < 50 ? \"#ff6b6b\" : progress < 80 ? \"#feca57\" : \"#48cae4\";\n              ctx.fillRect(this.state.x + 10, this.state.y + this.state.height - 15, progressWidth, 8);\n\n              // Cadre de la barre de progression\n              ctx.strokeStyle = \"#ddd\";\n              ctx.lineWidth = 1;\n              ctx.strokeRect(this.state.x + 10, this.state.y + this.state.height - 15, this.state.width - 20, 8);\n\n              // Texte avec pourcentage et nom\n              ctx.fillStyle = \"#2d3436\";\n              ctx.font = \"12px Arial\";\n              ctx.textAlign = \"center\";\n              ctx.fillText(`${Math.round(progress)}%`, this.state.x + this.state.width / 2, this.state.y + 20);\n              ctx.fillText(this.state.name, this.state.x + this.state.width / 2, this.state.y + 40);\n            }\n          }\n\n          ```\n\n\n          #### Personnalisation des connexions\n\n\n          De même, si vous devez modifier le comportement et l’apparence des liens —\n          par exemple pour montrer l’intensité du flux de données entre les blocs —\n          vous pouvez créer une connexion personnalisée :\n\n\n          ```json\n\n          import { BlockConnection } from \"@gravity-ui/graph\";\n\n\n          class DataFlowConnection extends BlockConnection {\n            public override style(ctx: CanvasRenderingContext2D) {\n              // Récupérer des données de flux depuis les blocs liés\n              const sourceBlock = this.sourceBlock;\n              const targetBlock = this.targetBlock;\n\n              const sourceProgress = sourceBlock?.state.meta?.progress || 0;\n              const targetProgress = targetBlock?.state.meta?.progress || 0;\n\n              // Calculer l’intensité du flux selon la progression des blocs\n              const flowRate = Math.min(sourceProgress, targetProgress);\n              const isActive = flowRate > 10; // Flux actif si progression > 10%\n\n              if (isActive) {\n                // Flux actif -- ligne verte épaisse\n                ctx.strokeStyle = \"#00b894\";\n                ctx.lineWidth = Math.max(2, Math.min(6, flowRate / 20));\n              } else {\n                // Flux inactif -- ligne grise en pointillés\n                ctx.strokeStyle = \"#ddd\";\n                ctx.lineWidth = this.context.camera.getCameraScale();\n                ctx.setLineDash([5, 5]);\n              }\n\n              return { type: \"stroke\" };\n            }\n          }\n\n          ```\n\n\n          #### Utilisation de composants personnalisés\n\n\n          On enregistre les composants créés dans la configuration du graphe :\n\n\n          ```json\n\n          const customGraph = new Graph({\n            blocks: [\n              {\n                id: \"task1\",\n                is: \"progress\",\n                x: 100,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Data Processing\",\n                meta: { progress: 75 },\n              },\n              {\n                id: \"task2\",\n                is: \"progress\",\n                x: 400,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Analysis\",\n                meta: { progress: 30 },\n              },\n              {\n                id: \"task3\",\n                is: \"progress\",\n                x: 700,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"Output\",\n                meta: { progress: 5 },\n              },\n            ],\n            connections: [\n              { sourceBlockId: \"task1\", targetBlockId: \"task2\" },\n              { sourceBlockId: \"task2\", targetBlockId: \"task3\" },\n            ],\n            settings: {\n              // Enregistrer des blocs personnalisés\n              blockComponents: {\n                'progress': ProgressBlock,\n              },\n              // Enregistrer une connexion personnalisée pour tous les liens\n              connection: DataFlowConnection,\n              useBezierConnections: true,\n            },\n          });\n\n\n          customGraph.setEntities({\n            blocks: [\n              {\n              is: 'progress',\n              id: '1',\n              name: \"progress block',\n              x: 10, \n              y: 10, \n              width: 10, \n              height: 10,\n              anchors: [],\n              selected: false,\n              }\n            ]\n          })\n\n\n          customGraph.start();\n\n          ```\n\n\n          #### Résultat\n\n\n          Au final, on obtient un graphe où :\n\n            * les blocs affichent la progression actuelle avec un code couleur ;\n            * les connexions visualisent le flux de données : flux actifs — verts et épais, flux inactifs — gris et en pointillés ;\n            * au zoom, les blocs basculent automatiquement en mode HTML avec interactivité complète.\n\n          ### Extension via des couches\n\n\n          Les couches (layers) sont des éléments Canvas ou HTML supplémentaires insérés dans « l’espace » du graphe.\n          En pratique, chaque couche est un canal de rendu distinct pouvant contenir son propre canvas\n          pour des graphismes rapides ou un conteneur HTML pour des éléments interactifs complexes.\n\n\n          D’ailleurs, c’est via les couches que fonctionne l’intégration React de notre bibliothèque :\n          les composants React sont rendus dans la couche HTML via React Portal.\n\n\n          #### Architecture des couches\n\n\n          Les couches sont une autre réponse clé au dilemme Canvas vs HTML.\n          Elles synchronisent les positions des éléments Canvas et HTML, garantissant leur superposition correcte.\n          Cela permet de basculer de manière fluide entre Canvas et HTML tout en restant dans un espace unique.\n          Le graphe est composé de couches indépendantes superposées :\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic7.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Les couches peuvent fonctionner dans deux systèmes de coordonnées :\n\n            * Liées au graphe (`transformByCameraPosition: true`) :\n\n              * les éléments bougent avec la caméra,\n              * blocs, connexions, éléments du graphe.\n\n            * Fixées à l’écran (`transformByCameraPosition: false`) :\n\n              * restent en place lors du panoramique,\n              * barres d’outils, légendes, contrôles UI.\n\n          #### Comment l’intégration React est construite\n\n\n          Une couche avec intégration React illustre bien ce que sont les couches.\n          Commençons par un composant qui met en évidence la liste des blocs\n          situés dans la zone visible de la caméra. Pour cela, on doit s’abonner aux changements\n          de caméra et, après chaque changement, vérifier l’intersection du viewport de la caméra\n          avec la hitbox des éléments.\n\n\n          ```json\n\n          import { Graph } from \"@gravity-ui/graph\";\n\n\n          const BlocksList = ({ graph, renderBlock }: { graph: Graph,\n          renderBlock: (graph: Graph, block: TBlock) => React.JSX.Element }) =>\n          {\n            const [blocks, setBlocks] = useState([]);\n\n            const updateVisibleList = useCallback(() => {\n              const cameraState = graph.cameraService.getCameraState();\n              const CAMERA_VIEWPORT_TRESHOLD = 0.5;\n              const x = -cameraState.relativeX - cameraState.relativeWidth * CAMERA_VIEWPORT_TRESHOLD;\n              const y = -cameraState.relativeY - cameraState.relativeHeight * CAMERA_VIEWPORT_TRESHOLD;\n              const width = -cameraState.relativeX + cameraState.relativeWidth * (1 + CAMERA_VIEWPORT_TRESHOLD) - x;\n              const height = -cameraState.relativeY + cameraState.relativeHeight * (1 + CAMERA_VIEWPORT_TRESHOLD) - y;\n              \n              const blocks = graph\n                .getElementsOverRect(\n                  {\n                    x,\n                    y,\n                    width,\n                    height,\n                  }, // définit la zone dans laquelle on cherchera la liste des blocs\n                  [CanvasBlock] // définit les types d’éléments recherchés dans la zone visible de la caméra\n                ).map((component) => component.connectedState); // obtenir la liste des modèles de blocs\n\n                setBlocks(blocks);\n            });\n\n              useGraphEvent(graph, \"camera-change\", ({ scale }) => {\n                if (scale >= 0.7) {\n                  // Si l’échelle est > 0.7, on met à jour la liste des blocs\n                  updateVisibleList()\n                  return;\n                }\n                setBlocks([]);\n              });\n\n              return blocks.map(block => <React.Fragment key={block.id}>{renderBlock(graphObject, block)}</React.Fragment>)\n          }\n\n          ```\n\n\n          Maintenant, regardons la définition de la couche elle-même qui utilisera ce composant.\n\n\n          ```json\n\n          import { Layer } from '@gravity-ui/graph';\n\n\n          class ReactLayer extends Layer {\n            constructor(props: TReactLayerProps) {\n              super({\n                html: {\n                  zIndex: 3, // placer la couche au-dessus des autres\n                  classNames: [\"no-user-select\"], // ajouter une classe pour désactiver la sélection de texte\n                  transformByCameraPosition: true, // couche liée à la caméra : elle bouge avec la caméra\n                },\n                ...props,\n              });\n            }\n\n            public renderPortal(renderBlock: <T extends TBlock>(block: T) => React.JSX.Element) {\n              if (!this.getHTML()) {\n                return null;\n              }\n\n              const htmlLayer = this.getHTML() as HTMLDivElement;\n\n              return createPortal(\n                React.createElement(BlocksList, {\n                  graph: this.context.graph,\n                  renderBlock: renderBlock,\n                }),\n                htmlLayer,\n              );\n            }\n          }\n\n          ```\n\n\n          Nous pouvons maintenant utiliser cette couche dans notre application.\n\n\n          ```json\n\n          import { Flex } from \"@gravity-ui/uikit\";\n\n\n          const graph = useMemo(() => new Graph());\n\n          const containerRef = useRef<HTMLDivElement>();\n\n\n          useEffect(() => {\n              if (containerRef.current) {\n                graph.attach(containerRef.current);\n              }\n\n              return () => {\n                graph.detach();\n              };\n            }, [graph, containerRef]);\n\n\n          const reactLayer = useLayer(graph, ReactLayer, {});\n\n\n          const renderBlock = useCallback((graph, block) => <Block graph={graph}\n          block={block}>{block.name}</Block>)\n\n            return (\n              <div>\n                <div style={{ position: \"absolute\", overflow: \"hidden\", width: \"100%\", height: \"100%\" }} ref={containerRef}>\n                  {graph && reactLayer && reactLayer.renderPortal(renderBlock)}\n                </div>\n              </div>\n            );\n          ```\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Globalement, tout est assez simple. Rien de ce qui a été décrit ci-dessus\n          n’a besoin d’être réécrit : tout est déjà implémenté et prêt à l’emploi.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Notre bibliothèque de graphes : avantages et utilisation{#library}\n\n\n          Quand nous avons commencé à travailler sur la bibliothèque, la question principale était :\n          comment faire en sorte que le développeur n’ait pas à choisir entre performance\n          et confort de développement ? La réponse a été d’automatiser ce choix.\n\n\n          ### Avantages\n\n\n          #### Performance + confort\n\n\n          [@gravity‑ui/graph](https://github.com/gravity-ui/graph){target=\"_blank\"}\n          bascule automatiquement entre Canvas et HTML en fonction du zoom.\n          Cela signifie :\n\n            * 60 FPS stables sur des graphes de milliers d’éléments.\n            * Possibilité d’utiliser de véritables composants HTML riches en interactivité lors d’une vue détaillée.\n            * Un modèle d’événements unique quel que soit le rendu — click, mouseenter fonctionnent de la même façon sur Canvas et en HTML.\n\n          #### Compatibilité avec les bibliothèques UI\n\n\n          L’un des principaux avantages est la compatibilité avec n’importe quelle bibliothèque UI.\n          Si votre équipe utilise :\n\n            * Gravity UI,\n            * Material‑UI,\n            * Ant Design,\n            * des composants custom.\n\n          … alors vous n’avez pas à y renoncer ! En zoomant, le graphe passe automatiquement\n          en mode HTML, où les `Button`, `Select`, `DatePicker` habituels, avec votre thème de couleurs,\n          fonctionnent exactement comme dans une application React classique.\n\n\n          #### Agnostique au framework\n\n\n          Bien que nous ayons implémenté le renderer HTML de base avec React,\n          nous avons conçu la bibliothèque pour rester agnostique au framework.\n          Cela signifie qu’en cas de besoin, vous pouvez assez simplement implémenter\n          une couche d’intégration pour votre framework préféré.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Existe-t-il des alternatives ?{#analogs}\\n\\nIl existe aujourd’hui beaucoup de solutions pour dessiner des graphes — des solutions payantes comme [yFiles](https://yfiles.dev/){target=\\\"_blank\\\"} et [JointJS](https://github.com/clientIO/joint){target=\\\"_blank\\\"}, jusqu’aux solutions open source [Foblex Flow](https://github.com/Foblex/f-flow){target=\\\"_blank\\\"}, [baklavajs](https://github.com/newcat/baklavajs){target=\\\"_blank\\\"} et [jsPlumb](https://github.com/jsplumb/community-edition){target=\\\"_blank\\\"}. Pour la comparaison, nous retenons [@antv/g6](https://github.com/antvis/G6){target=\\\"_blank\\\"} et [React Flow](https://github.com/xyflow/xyflow){target=\\\"_blank\\\"} comme les outils les plus populaires. Chacun a ses particularités.\\n\\nReact Flow est une bonne bibliothèque orientée vers la construction d’interfaces node‑based. Elle offre de nombreuses fonctionnalités, mais à cause de l’utilisation de SVG et HTML, les performances restent assez modestes. Elle est adaptée lorsqu’on est certain que les graphes ne dépasseront pas 100–200 blocs.\\n\\nDe son côté, @antv/g6 dispose d’un grand nombre de fonctionnalités ; elle supporte Canvas et notamment WebGL. Comparer directement @antv/g6 et @gravity‑ui/graph n’est probablement pas tout à fait juste : l’équipe est davantage orientée graphes et diagrammes, même si le node‑based UI est aussi supporté. antv/g6 est donc un bon choix si vous avez besoin non seulement d’un node‑based UI, mais aussi de dessiner des graphiques/diagrammes.\\n\\nMême si @antv/g6 sait faire canvas/webgl et html/svg, il faut gérer soi‑même les règles de bascule, et les faire correctement. En performance, elle est bien plus rapide que React Flow, mais elle soulève tout de même des questions. Bien que le support WebGL soit annoncé, leur [stress test](https://g6.antv.antgroup.com/en/examples/performance/massive-data#60000){target=\\\"_blank\\\"} montre qu’à 60k nœuds, la bibliothèque n’assure pas une dynamique fluide — sur un MacBook M3, le rendu d’une image a pris 4 secondes. À titre de comparaison, notre [stress test](https://preview.gravity-ui.com/graph/?path=/story/stories-main-grapheditor--graph-stress-test){target=\\\"_blank\\\"} avec 111k nœuds et 109k connexions sur le même MacBook M3 : le rendu de la scène du graphe entier prend ~60ms, soit ~15–20 FPS. Ce n’est pas énorme, mais grâce au Spatial Culling, on peut restreindre le viewport et ainsi améliorer la réactivité. Même si les mainteneurs [avaient indiqué](https://github.com/antvis/G6/issues/1597){target=\\\"_blank\\\"} vouloir atteindre 30 FPS pour 100k nœuds, il semble qu’ils n’y soient pas encore parvenus.\\n\\nUn autre point où @gravity‑ui/graph l’emporte : la taille du bundle.\\n\\n#|\\n|||Bundle size Minified|Bundle size Minified + Gzipped||\\n||@antv/g6 [bundlephobia](https://bundlephobia.com/package/@antv/g6@5.0.49){target=\\\"_blank\\\"}|1.1 MB|324.5\\_kB||\\n||react flow [bundlephobia](https://bundlephobia.com/package/@xyflow/react@12.8.1){target=\\\"_blank\\\"}|181.2\\_kB|56.4\\_kB||\\n||@gravity-ui/graph [bundlephobia](https://bundlephobia.com/package/@gravity-ui/graph){target=\\\"_blank\\\"}|2.2\\_kB|672\\_B||\\n|#\\n\\nBien que ces deux bibliothèques soient très solides en performance ou en facilité d’intégration, @gravity‑ui/graph présente plusieurs avantages : elle peut assurer des performances sur des graphes vraiment volumineux tout en préservant l’UI/UX côté utilisateur et en simplifiant le développement.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Plans pour l’avenir{#future}\n\n\n          La bibliothèque dispose déjà d’une marge de performance suffisante pour la plupart des cas.\n          Dans un avenir proche, nous allons donc davantage nous concentrer sur le développement\n          de l’écosystème autour de la bibliothèque : création de couches (plugins), intégrations\n          pour d’autres bibliothèques et frameworks (Angular/Vue/Svelte, …etc), ajout du support\n          des appareils tactiles, adaptation aux navigateurs mobiles et amélioration globale de l’UX/DX.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Essayez et rejoignez-nous{#try}\n\n\n          Dans le [dépôt](https://github.com/gravity-ui/graph){target=\"_blank\"},\n          vous trouverez une bibliothèque entièrement fonctionnelle :\n\n            * un cœur Canvas + R‑Tree (≈ 30k lignes de code),\n            * une intégration React,\n            * un Storybook avec des exemples.\n\n          Installer la bibliothèque se fait en une seule ligne :\n\n\n          `npm install @gravity-ui/graph`\n\n\n          --------------\n\n\n          Pendant longtemps, la bibliothèque qui s’appelle aujourd’hui @gravity‑ui/graph\n          était un outil interne de Nirvana, et l’approche choisie a fait ses preuves.\n          Nous souhaitons maintenant partager notre travail et aider les développeurs externes\n          à dessiner leurs graphes plus simplement, plus vite et de manière plus performante.\n\n\n          Nous voulons standardiser les approches d’affichage de graphes complexes dans\n          la communauté open source — trop d’équipes réinventent la roue ou souffrent\n          avec des outils inadaptés.\n\n\n          C’est pourquoi votre feedback est très important : des projets différents apportent\n          des cas limites différents, qui aident à faire évoluer la bibliothèque.\n          Cela nous permettra de l’améliorer et d’accélérer la croissance de l’écosystème Gravity UI.\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
    "title": "",
    "noIndex": false,
    "shareTitle": null,
    "shareDescription": null,
    "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png",
    "pageLocaleId": null,
    "author": "timofeyevvv",
    "metaDescription": null,
    "keywords": [],
    "shareGenTitle": null,
    "canonicalLink": null,
    "sharingType": "semi-full",
    "sharingTheme": "dark",
    "comment": "sharing pic",
    "shareImageUrl": "https://storage.cloud-preprod.yandex.net/ui-api-ru-preprod-stable-share-generator-screenshots/cache/b155df2ab692d6e154ff809a7d91b9ad4789de53.png",
    "pageRegionId": 76,
    "summary": null,
    "versionId": 216,
    "service": null,
    "solution": null,
    "locales": [
      {
        "id": 75,
        "pageId": 71,
        "locale": "ru",
        "createdAt": "2026-01-15T11:26:48.440Z",
        "updatedAt": "2026-01-15T11:26:48.519Z",
        "publishedVersionId": null,
        "lastVersionId": 195
      },
      {
        "id": 76,
        "pageId": 71,
        "locale": "en",
        "createdAt": "2026-01-15T11:26:48.532Z",
        "updatedAt": "2026-01-15T11:26:48.609Z",
        "publishedVersionId": null,
        "lastVersionId": 196
      }
    ],
    "pageRegions": [
      {
        "regionCode": "ru-ru",
        "publishedVersionId": 199
      },
      {
        "regionCode": "en",
        "publishedVersionId": 216
      }
    ],
    "searchCategory": {
      "id": 7,
      "slug": "blog",
      "title": "Blog",
      "url": "/blog"
    },
    "voiceovers": []
  }
  