{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:57:57.515Z",
  "updatedAt": "2026-01-27T13:57:57.515Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "en",
  "publishedVersionId": 268,
  "lastVersionId": 268,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **Ilia Lomtev**\n\n          Développeur frontend\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          Dans cet article :\n\n            - [Comment et pourquoi nous avons créé AIKit](#why)\n            - [Architecture d’AIKit : sur quoi nous nous sommes appuyés](#architecture)\n            - [Comment construire son propre chat](#how)\n            - [Comment AIKit a influencé les services](#influence)\n            - [Et ensuite](#further)\n            - [Comment essayer AIKit](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nAu cours de l’année écoulée, nous observons un boom des assistants IA, et cela a aussi touché les interfaces de Yandex\\_Cloud : tantôt un chatbot avec un modèle est apparu au support, tantôt — dans la console — un agent pour les opérations courantes. Les équipes connectaient des modèles, réfléchissaient à la logique conversationnelle, concevaient le design et assemblaient des chats — et elles faisaient tout cela chacune de leur côté.\\n\\nDifférentes équipes construisaient des interfaces sur le framework commun Gravity UI, mais peu à peu il est apparu tellement de variantes qu’il est devenu difficile de maintenir une expérience utilisateur cohérente. Et les collègues se retrouvaient de plus en plus souvent à perdre du temps à résoudre les mêmes problèmes.\\n\\nPour arrêter de réinventer la roue à chaque fois, nous avons rassemblé les pratiques accumulées dans une approche unique et créé un outil pour les chatbots IA — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}. Il permet de créer une interface d’assistant complète en quelques jours et, en même temps, de l’adapter facilement à différents scénarios.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nJe m’appelle Ilia Lomtev, je suis développeur senior dans l’équipe Foundation Services de Yandex\\_Cloud, et dans cet article je vais expliquer pourquoi nous avons décidé de construire AIKit, comment il est conçu, un peu de nos plans pour l’avenir — et ce que vous pouvez essayer de votre côté.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Comment et pourquoi nous avons créé AIKit{#why}\\n\\nAu cours de l’année écoulée, le nombre de services avec des assistants IA dans Yandex\\_Cloud a augmenté, par exemple : \\n\\n  * Code Assistant Chat dans SourceCraft — l’assistant aide les développeurs à écrire du code et, en mode agent IA, crée et configure des dépôts, lance des processus CI/CD, répond aux questions sur la documentation et automatise des tâches. Il sait aussi gérer les issues et les pull requests, et travailler avec le code : expliquer, créer et éditer des fichiers.\\n\\n  * Assistant IA dans la console cloud — un assistant conçu pour gérer les ressources dans Yandex\\_Cloud. L’objectif principal est d’aider à configurer, modifier et administrer l’infrastructure cloud rapidement et en toute sécurité, en masquant la complexité de l’interaction avec l’API et les outils.\\n\\nDans l’écosystème, une dizaine de chats sont apparus, chacun avec sa logique, son format de messages et son ensemble de cas limites. \\n\\nNous avons constaté que les équipes aboutissent à un ensemble de tâches à peu près similaire. Ce dont la majorité a besoin : \\n\\n  * afficher proprement les messages de l’utilisateur et de l’assistant, \\n\\n  * organiser correctement le streaming des réponses, \\n\\n  * afficher l’indicateur « l’assistant écrit », \\n\\n  * gérer des erreurs comme une connexion interrompue ou des retries. \\n\\nLes tâches sont essentiellement les mêmes, mais il existe de nombreuses façons de les résoudre, et l’UX diffère. Par exemple, l’emplacement et la manière d’afficher l’historique des chats : cela peut être un écran séparé qui s’ouvre comme un menu, ou une liste de chats dans un popup.\\n\\nUn problème est apparu : l’expérience dans les différents chats différait sensiblement. Ici l’assistant streamait la réponse, là il affichait immédiatement le texte final. Dans une interface, les messages étaient regroupés, dans une autre — ils défilaient en un flux continu. Cela cassait l’UX global — l’utilisateur passe d’un produit à l’autre au sein du même écosystème, mais les sensations avec l’assistant sont complètement différentes.   \\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: Exemples de chats construits avec AIKit, en thème clair\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Il est également devenu évident que le déploiement de nouvelles\n          fonctionnalités dans les modèles devenait de plus en plus difficile.\n          Pour apporter aux utilisateurs, par exemple, les capacités d’outils,\n          la multimodalité ou des réponses d’outils structurées, il fallait\n          aligner le contrat, faire évoluer les backends, puis mettre à jour\n          l’UI dans chaque équipe séparément. Dans ces conditions, toute\n          modification prenait beaucoup de temps et se prêtait mal au passage à\n          l’échelle.\n\n\n          Nous voulions arrêter cette croissance de la variabilité et retrouver\n          de la prévisibilité. Pour cela, il fallait unifier le modèle de\n          données et les patterns de travail, fournir des composants et des\n          hooks prêts à l’emploi afin que les équipes n’aient pas à repartir de\n          zéro, et laisser de la place à la personnalisation — car les scénarios\n          diffèrent pour chacun. \n\n\n          C’est ainsi que nous en sommes arrivés à l’idée d’une bibliothèque\n          séparée @gravity‑ui/aikit — une extension de Gravity UI qui suit les\n          mêmes principes, mais qui est orientée vers les scénarios IA modernes :\n          dialogues, assistants, multimodalité.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Architecture d’AIKit : sur quoi nous nous sommes appuyés{#architecture}\\n\\nEn concevant AIKkit, nous nous sommes appuyés sur l’expérience de [AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"} ainsi que sur plusieurs principes fondamentaux.\\n\\n**Atomic Design comme fondation** : toute la bibliothèque est construite des atomes aux pages. Cette structure donne une hiérarchie claire, permet de réutiliser les composants et, si besoin, de modifier le comportement à n’importe quel niveau.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**Entièrement agnostique du SDK** : AIKit ne dépend pas d’un fournisseur d’IA particulier. On peut utiliser OpenAI, Alice\\_AI LLM ou son propre backend — l’UI reçoit les données via des props, tandis que l’état et les requêtes restent du côté du produit. \\n\\n**Deux niveaux d’utilisation pour des scénarios complexes** : il existe un composant prêt à l’emploi qui fonctionne « out of the box », et un hook contenant la logique, qui permet de contrôler entièrement l’UI. Par exemple, on peut utiliser `PromptInput` ou construire son propre champ de saisie sur la base de `usePromptInput`. Cela apporte de la flexibilité sans devoir réécrire les fondations.\\n\\n**Système de types extensible**. Pour assurer l’uniformité et la sécurité de typage, nous avons construit un modèle de données extensible. Les messages sont représentés par une structure unique typée : il y a des messages utilisateur, des messages assistant et plusieurs types de contenu de base — texte (`text`), raisonnement du modèle (`thinking`), outils (`tool`). En même temps, on peut ajouter ses propres types via `MessageRendererRegistry`. \\n\\nTout est typé en TypeScript, ce qui aide à construire plus vite des scénarios complexes et à éviter des erreurs dès la phase de développement.\\n\\n```javascript\\n// 1. Définir le type de données\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. Créer le composant de rendu\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>Visualisation du graphique : {part.data.chartType}</div>;\\n};\\n// 3. Enregistrer le renderer\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. Utiliser dans AssistantMessage\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\nEnfin, nous avons prévu la thématisation via des variables CSS, ajouté l’i18n (RU/EN), assuré l’accessibilité (ARIA, navigation au clavier) et configuré des tests de régression visuelle via Playwright Component Testing dans Docker — et la bibliothèque était prête pour un usage en production.\\n\\n### Ce qu’il y a sous le capot \\n\\nAu cœur d’AIKit se trouve un modèle de dialogue unique. Pour le créer, il a d’abord fallu comprendre la hiérarchie des messages. \\n\\nLes messages sont des entités assez polyvalentes. Il y a le premier message du LLM — c’est un stream. Mais à l’intérieur, il peut y avoir beaucoup de messages imbriqués différents : en substance, ce sont des raisonnements, des propositions, des appels à des outils pour résoudre une question. Tous ces sous-messages différents constituent en réalité un seul message provenant du backend. Mais chacun d’entre eux peut aussi très bien être un message distinct dans une utilisation simple d’un LLM. \\n\\nC’est pourquoi nous avons laissé la possibilité d’utiliser le chat des deux manières : les messages peuvent être imbriqués les uns dans les autres, ou être plats — tout dépend du besoin.\\n\\nLa gestion d’état, quant à elle, reste du côté du service. AIKit ne stocke pas les données lui-même — il les reçoit de l’extérieur. Les équipes peuvent utiliser React State, Redux, Zustand, Reatom — ce qui leur convient. Nous fournissons seulement des hooks qui encapsulent la logique UI typique, par exemple : \\n\\n  * un défilement intelligent avec `useSmartScroll` ;\\n\\n  * le travail avec les dates, par exemple le formatage des dates selon la locale avec `useDateFormatter` ; \\n\\n  * le traitement des messages d’outils avec `useToolMessage` ;\\n\\n  * et tout le reste nécessaire à la construction d’un dialogue.\\n\\nEn plus de cela, AIKit reste extensible. On peut connecter n’importe quels modèles, créer ses propres types de contenu et construire une UI entièrement adaptée à ses tâches — en s’appuyant sur la logique des hooks ou en utilisant des composants prêts à l’emploi comme base. L’architecture permet d’expérimenter sans violer les principes communs.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Comment construire son propre chat{#how}\n\n\n          Pour créer notre premier chat, utilisons le composant préparé\n          ChatContainer :\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // Your message sending logic\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // Update state\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'Start a conversation by typing a message or selecting a suggestion.',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: 'Try asking:',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: 'Explain quantum computing in simple terms'\n                  },\n                  {\n                    id: '2',\n                    title: 'Write a poem about nature'\n                  },\n                  {\n                    id: '3',\n                    title: 'Help me debug my JavaScript code'\n                  },\n                  {\n                    id: '4',\n                    title: 'Summarize recent AI developments'\n                  }\n                ],\n                title: 'Welcome to AI Chat'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          « Out of the box », tout ressemble à ceci :\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Ajoutons un peu d’ambiance festive : \n\n\n          1. Corrigeons l’état initial. \n\n              Pour un réglage plus fin, assemblons le chat à partir de composants séparés : `Header`, `MessageList`, `PromptBox`.\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AI Assistant\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"Demandez n’importe quoi...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. Utilisons différents types de messages intégrés, importés via\n          `MessageType`.\n\n              * `thinking` — affichera le processus de réflexion de l’IA (l’utilisateur peut ainsi étudier la logique selon laquelle l’assistant prépare la réponse).\n\n              * `tool` — convient pour afficher des blocs de réponse interactifs ; dans notre cas, c’est un bloc de code où la coloration syntaxique fonctionne correctement et où les opérations d’édition et de copie dans le presse-papiers sont prises en charge.\n\n              On peut aussi ajouter ses propres types, par exemple des messages avec des images :\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. Ajoutons une stylisation via CSS…\n\n              …et nous obtiendrons un chat avec Ded Moroz :)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          Pour une personnalisation complète d’éléments individuels, vous pouvez\n          utiliser des hooks — nous serons ravis de voir vos variantes de style\n          dans les commentaires sous l’article !\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Comment AIKit a influencé les services{#influence}\\n\\nLe résultat de l’utilisation d’AIKit dans Yandex\\_Cloud s’est fait sentir rapidement. Dans tous les services, les assistants ont commencé à se comporter de la même manière : streamer les réponses de façon identique, afficher les erreurs de façon identique, regrouper les messages de façon identique. L’UX est devenu uniforme ; il est désormais plus simple d’interagir avec lui dans l’ensemble de l’écosystème, le comportement est plus attendu et plus prévisible.\\n\\n  * Le langage UX est devenu unique — les chats d’assistants dans différents produits sont désormais perçus comme faisant partie d’un même écosystème. Les utilisateurs voient un comportement prévisible : même streaming, même gestion des erreurs, mêmes patterns d’interaction. \\n\\n  * La vitesse de développement de l’UI du chat est nettement plus élevée. \\n\\n  * Développement centralisé — de nouvelles fonctionnalités comme le type de contenu thinking ou une meilleure gestion des outils sont ajoutées une seule fois et deviennent automatiquement disponibles pour tous. \\n\\n  * La bibliothèque est devenue une base pour la formation de standards d’interfaces IA dans l’écosystème.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Et ensuite{#further}\n\n\n          Parlons maintenant des plans. Nous avons identifié plusieurs axes : \n\n            * Amélioration des performances via la virtualisation pour travailler avec des historiques de chat très volumineux. \n\n            * Extension des scénarios de base pour les nouvelles capacités des agents IA, qui se développent activement. \n\n            * Ajout d’utilitaires afin de simplifier le mapping des données de modèles IA populaires vers notre modèle de données de chat. \n\n          En plus, nous développerons la documentation et les exemples. Et bien\n          sûr, le développement de la communauté — nous voulons que la\n          bibliothèque soit utile non seulement en interne, mais aussi aux\n          développeurs externes.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Comment essayer AIKit{#try}\n\n\n          Rendez-vous dans la [section\n          bibliothèque](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}\n          sur notre site. Si vous créez votre propre assistant IA, que vous\n          voulez une interface de chat rapide et prévisible et que vous utilisez\n          déjà Gravity UI (ou êtes prêt à l’essayer), jetez un œil au README et\n          aux exemples. Et nous vous serons aussi reconnaissants pour vos\n          retours — ouvrez des issues, envoyez des PR, dites-nous ce dont vous\n          avez encore besoin pour vos scénarios !\n\n\n          Si vous aimez notre projet, nous serons ravis d’avoir une ⭐️ sur\n          [AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"} et\n          [UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"} !\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "initial en",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 117,
  "summary": null,
  "versionId": 268,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "ru",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "ru-ru",
      "publishedVersionId": null
    },
    {
      "regionCode": "en",
      "publishedVersionId": 268
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "Blog",
    "url": "/blog"
  },
  "voiceovers": []
}