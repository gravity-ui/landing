{
    "id": 71,
    "name": "blog/graph",
    "createdAt": "2026-01-15T11:28:28.437Z",
    "updatedAt": "2026-01-15T11:28:28.437Z",
    "type": "default",
    "isDeleted": false,
    "versionOnTranslationId": null,
    "searchCategorySlug": "blog",
    "regions": [],
    "pageId": 71,
    "regionCode": "ja",
    "publishedVersionId": 199,
    "lastVersionId": 199,
    "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#CCDAFF'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/speaker.jpg\n          =80x)\n\n\n          **アンドレイ・シェチニン**\n\n          シニアインターフェース開発者\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          この記事の内容：\n\n            - [タスクの由来](#task)\n            - [ソリューションに至った経緯](#solution)\n            - [カスタマイズ](#customization)\n            - [私たちのグラフライブラリ：利点と使い方](#library)\n            - [代替品はあるか？](#analogs)\n            - [今後の計画](#future)\n            - [試して参加してください](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          こんにちは！私はアンドレイ、Yandexのインフラストラクチャサービスユーザーエクスペリエンスチームのインターフェース開発者です。私たちはGravity UIを開発しています — 社内外の数十の製品で使用されているオープンソースのデザインシステムとReactコンポーネントライブラリです。今日は、複雑なグラフの可視化タスクに直面した経緯、既存のソリューションがなぜ満足できなかったのか、そして最終的に@gravity‑ui/graph — コミュニティにオープンにすることにしたライブラリ — がどのように生まれたかをお話しします。\n\n\n          この物語は実際の問題から始まりました：インタラクティブなコンポーネントを持つ10,000以上の要素のグラフをレンダリングする必要がありました。Yandexには、ユーザーが複雑なデータ処理パイプラインを作成するプロジェクトが多数あります — シンプルなETLプロセスから機械学習まで。そのようなパイプラインがプログラムで作成される場合、ブロックの数は数万に達することがあります。\n\n\n          既存のソリューションには満足できませんでした：\n\n            * **HTML/SVGライブラリ**は見た目が良く、開発が便利ですが、数百の要素でも遅くなり始めます。\n            * **Canvasソリューション**はパフォーマンスに対応できますが、複雑なUI要素を作成するには膨大なコードが必要です。\n\n          Canvasで角丸とグラデーションのあるボタンを描くのはそれほど難しくありません。しかし、独自の複雑なコントロールやレイアウトを作成する必要があるときに問題が発生します — 数十行の低レベルの描画コマンドを書く必要があります。各インターフェース要素をゼロからプログラミングする必要があります — クリック処理からアニメーションまで。私たちが必要としていたのは、本格的なUIコンポーネント：ボタン、セレクト、入力フィールド、ドラッグアンドドロップでした。\n\n\n          私たちはCanvasとHTMLのどちらかを選ぶのではなく、両方の技術の良いところを使うことにしました。アイデアはシンプルでした：ユーザーがグラフをどれだけ近くで見ているかに応じて、モード間を自動的に切り替えます。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: |\n\n          #### 自分で試してみてください\n\n            * [GitHubリポジトリ](https://github.com/gravity-ui/graph){target=\"_blank\"}\n            * [サンプル付きStorybook](https://preview.gravity-ui.com/graph/){target=\"_blank\"}\n            * [Playground](https://gravity-ui.com/ru/libraries/graph/playground){target=\"_blank\"}\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## タスクの由来{#task}\n\n\n          ### Nirvanaとそのグラフ\n\n\n          Yandexには、データ処理グラフを作成・実行するためのNirvanaというサービスがあります（2018年に[記事](https://habr.com/ru/companies/yandex/articles/351016/){target=\"_blank\"}を書きました）。サービスは大規模で人気があり、長い間存在しています。\n\n\n          一部のユーザーは手動でグラフを作成します — マウスを動かし、ブロックを追加し、接続します。そのようなグラフには問題ありません：ブロックが少なく、すべてがうまく動作します。しかし、プログラムでグラフを作成するプロジェクトがあります。そしてここで複雑さが始まります：1つのグラフに最大10,000の操作を入れることができます。そして、このようになります：\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          {% cut \"そしてこんな感じにも：\" %}\n\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-1.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-2.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-3.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-4.png\n          =830x)\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic2-5.png\n          =830x)\n\n\n          {% endcut %}\n\n\n          そのようなグラフを通常のHTML + SVGの組み合わせは処理できません。ブラウザが遅くなり始め、メモリがリークし、ユーザーが苦しみます。問題を直接解決しようとしました：HTMLレンダリングを最適化しましたが、遅かれ早かれ物理的な制限にぶつかりました — DOMは同時に見える数千のフローティングインタラクティブ要素向けに設計されていません。\n\n\n          別のソリューションが必要で、ブラウザにはCanvasしか残っていません。必要なパフォーマンスを確保できるのはCanvasだけです。\n\n\n          最初の考え — 既製のソリューションを見つける。2017-2018年頃で、Canvasやグラフレンダリング用の人気のあるライブラリを調べましたが、すべてのソリューションが同じ問題にぶつかりました：Canvasとプリミティブな要素を使うか、HTML/SVGを使ってパフォーマンスを犠牲にするかです。\n\n\n          では、選ばないとしたら？\n\n\n          ### Level of Details：GameDevからのインスピレーション\n\n\n          GameDevと地図作成には素晴らしいコンセプトがあります — Level of Details (LOD)。この技術は必要性から生まれました — パフォーマンスを殺さずに巨大な世界をどう表示するか？\n\n\n          本質はシンプルです：1つのオブジェクトは、どれだけ近くで見られているかに応じて、複数のレベルの詳細を持つことができます。ゲームでは特に顕著です：\n\n            * 遠くに山が見えます — シンプルなポリゴンと基本的なテクスチャです。\n            * 近づくと — 詳細が現れます：草、石、影。\n            * さらに近づくと — 木の個々の葉が見えます。\n\n          プレイヤーが山頂に立って遠くを見ているとき、誰も何百万もの草のポリゴンをレンダリングしません。\n\n\n          地図でも原理は同じです — 各ズームレベルには独自のデータセットと詳細レベルがあります：\n\n            * 大陸スケール — 国だけが見えます。\n            * 都市にズームイン — 通りと地区が現れます。\n            * さらに近づくと — 建物番号、カフェ、バス停。\n\n          私たちは気づきました：ユーザーは10,000ブロックのグラフの大きなスケールでインタラクティブなボタンを必要としません — とにかく見えないし、操作もできません。\n\n\n          さらに、10,000のHTML要素を同時にレンダリングしようとすると、ブラウザがフリーズします。しかし、特定のエリアにズームインすると、見えるブロックの数は急激に減少します — 10,000から、例えば50に。ここでリソースが解放され、豊かなインタラクティビティを持つHTMLコンポーネントが使えます。\n\n\n          ### Level of Detailsスキームの3つのレベル\n\n\n          #### Minimalistic（スケール0.1-0.3）— シンプルなプリミティブ付きCanvas\n\n\n          このモードでは、ユーザーはシステムの全体的なアーキテクチャを見ます：主要なブロックグループがどこにあるか、それらがどのように接続されているか。各ブロックは基本的な色分けを持つシンプルな長方形です。テキスト、ボタン、詳細なアイコンはありません。しかし、何千もの要素を快適にレンダリングできます。このレベルで、ユーザーは詳細な調査のためのエリアを選択します。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Schematic（スケール0.3-0.7）— 詳細付きCanvas\n\n\n          ブロック名、状態アイコン、接続用のアンカーが表示されます。テキストはCanvas APIで描画されます — 高速ですが、スタイリングの可能性は限られています。ブロック間の接続がより情報豊富になります：データフローの方向、接続状態を表示できます。これはCanvasのパフォーマンスと基本的な情報性を組み合わせた移行モードです。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        paddingBottom: s\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic4.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          #### Detailed（スケール0.7+）— 完全なインタラクティビティを持つHTML\n\n\n          ここでブロックは本格的なインターフェースコンポーネントに変わります：コントロールボタン、パラメータフィールド、プログレスバー、セレクト。HTML/CSSのあらゆる機能を使用し、UIライブラリを接続できます。このモードでは、通常20-50個以下のブロックがビューポートに収まり、詳細な作業に快適です。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic5.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          **詳細レベルを選択するためにFPSをカウントするのはどうですか？**\n\n\n          FPSに基づいて詳細を選択するアプローチがありました。しかし、そのようなアプローチは不安定さを生み出すことがわかりました — パフォーマンスが向上するとシステムがより詳細なモードに切り替わり、FPSが低下して元に戻る切り替えを引き起こす可能性があります — そしてその繰り返しです。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## ソリューションに至った経緯{#solution}\n\n\n          よし、LODは素晴らしい。しかし、実装にはパフォーマンスのためにCanvasが必要で、これは新たな頭痛の種です。Canvasに描画するのはそれほど難しくありません — 問題はインタラクティビティを作る必要があるときに現れます。\n\n\n          ### 問題：ユーザーがどこをクリックしたかをどう理解するか？\n\n\n          HTMLではすべてがシンプルです：ボタンをクリックすると、要素で直接イベントを取得します。Canvasではより複雑です：キャンバスをクリックしました — それで？ユーザーがどの要素をクリックしたかを自分で把握する必要があります。\n\n\n          基本的に3つのアプローチがあります：\n\n            * Pixel Testing（カラーピッキング）\n            * Geometric approach（すべての要素の単純な反復）\n            * Spatial Indexing（空間インデックス）\n\n          #### Pixel Testing（カラーピッキング）\n\n\n          アイデアはシンプルです：2番目の非表示のキャンバスを作成し、そこにシーンをコピーしますが、各要素をオブジェクトのIDと見なされるユニークな色で塗りつぶします。クリック時に、getImageDataを通じてマウスポインターの下のピクセルの色を読み取り、要素のIDを取得します。\n\n\n          #|\n\n          ||**長所**|**短所**||\n\n          ||* 数十行で実装\n\n\n          * 追加のデータ構造が不要|* Canvasのアンチエイリアスが色を混ぜる — 図形の境界でクリックすると「無効な」IDが得られる可能性がある\n\n\n          * 2D-Canvasではアンチエイリアスをオフにできない\n\n\n          * 2番目のキャンバスがメモリを複製し、レンダーパスを2倍にする||\n\n          |#\n\n\n          小さなシーンには適していますが、10,000以上の要素ではエラー率が許容できなくなります — Pixel Testingは延期します。\n\n\n          #### Geometric approach（すべての要素の単純な反復）\n\n\n          アイデアはシンプルです：すべての要素を反復し、クリックポイントが要素の内側にあるかどうかをチェックします。\n\n\n          #|\n\n          ||**長所**|**短所**||\n\n          ||* 数十行で実装\n\n\n          * 追加のデータ構造が不要|* 要素が多いと非常に遅い\n\n\n          * 大きなシーンには適さない||\n\n          |#\n\n\n          #### Spatial Indexing\n\n\n          幾何学的アプローチの発展。幾何学的アプローチでは要素の数に限界がありました。空間インデックスアルゴリズムは、隣接する要素を何らかの方法でグループ化しようとし、主にツリーを使用することで、複雑さをlog nに減らすことができます。\n\n\n          空間インデックスアルゴリズムはかなり多くあり、[rbush](https://github.com/mourner/rbush){target=\"_blank\"}ライブラリの形でR-Treeデータ構造を選択しました。\n\n\n          R-Treeは、名前からわかるように、各オブジェクトが最小サイズの長方形（MBR）に配置され、それらの長方形がより大きな長方形にグループ化されるツリーです。こうして、各長方形が他の長方形を含むツリーが得られます。\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: >-\n          Wikipediaの[R‑tree](https://en.wikipedia.org/wiki/R-tree){target=\"_blank\"}からの画像\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic6.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          RTreeで検索するには、特定の要素に到達するまでツリーを下降（長方形の奥深く）する必要があります。パスは、検索長方形とMBRの交差をチェックすることで選択されます。バウンディングボックスが検索長方形に触れてさえいないすべてのブランチはすぐに破棄されます — これが、トラバースの深さが通常3-5レベルに制限され、検索自体が数万の要素でもマイクロ秒で完了する理由です。\n\n\n          このバリアントは、ピクセルテスト（最良の場合O(log n)、最悪の場合O(n)）よりも遅く動作しますが、より正確でメモリ要件が低いです。\n\n\n          #### イベントモデル\n\n\n          RTreeに基づいて、イベントモデルを構築できるようになりました。ユーザーがクリックすると、ヒットテストプロシージャが起動します：カーソル座標に1×1ピクセルの長方形を形成し、R-Treeでその交差を検索します。この長方形が収まる要素を取得したら、イベントをその要素に委任します。要素がイベントを停止しなかった場合、イベントはその親に渡され、ルートまで続きます。このモデルの動作は、ブラウザでおなじみのイベントモデルの動作に似ています。イベントはインターセプト、プリベント、または伝播を停止できます。\n\n\n          すでに述べたように、ヒットテスト中に1×1ピクセルの長方形を形成します。これは、任意のサイズの長方形を形成できることを意味します。そしてこれが、もう1つの非常に重要な最適化 — Spatial Culling — を行うのに役立ちます。\n\n\n          ### Spatial Culling\n\n\n          Spatial Cullingは、見えないものを描画しないことを目的としたレンダリング最適化技術です。例えば、カメラの空間外にあるオブジェクトや、シーンの他の要素に隠されているオブジェクトを描画しません。グラフは2D空間で描画されるため、カメラの可視領域（ビューポート）外にあるオブジェクトのみを描画しなければ十分です。\n\n\n          動作原理：\n\n            * カメラを移動またはズームするたびに、現在のビューポートに等しい長方形を形成します\n            * R-Treeでその交差を検索します\n            * 結果は実際に見える要素のリストになります\n            * それらだけをレンダリングし、他のすべてはスキップされます\n\n          このテクニックにより、パフォーマンスは要素の総数にほぼ依存しなくなります：フレームに40ブロックが収まる場合 — ライブラリは正確に40を描画し、画面外に隠れている数万は描画しません。遠いスケールでは多くの要素がビューポートに収まるため、軽量なCanvasプリミティブを描画し、カメラが近づくと要素数が減少し、解放されたリソースで完全な詳細を持つHTMLモードに切り替えることができます。\n\n\n          すべてをまとめると、シンプルなスキームになります：\n\n            * Canvasは速度を担当\n            * HTMLはインタラクティビティを担当\n            * R-TreeとSpatial Cullingは、どの要素をHTMLレイヤーに描画できるかをすばやく理解できるようにして、それらを単一のシステムに見えない形で統合します\n\n          カメラが動いている間、小さなビューポートはR-Treeに実際にフレーム内にあるオブジェクトのみを要求します。このアプローチにより、本当に大きなグラフを描画できます。少なくとも、ユーザーがビューポートを制限するまでパフォーマンスの余裕があります。\n\n\n          まとめると、ライブラリのコアには以下が含まれています：\n\n            * シンプルなプリミティブを持つCanvasモード\n            * 完全な詳細を持つHTMLモード\n            * パフォーマンス最適化のためのR-TreeとSpatial Culling\n            * おなじみのイベントモデル\n\n          しかし、本番環境にはこれだけでは不十分で、ライブラリを拡張し、ニーズに合わせてカスタマイズする機能が必要です。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## カスタマイズ{#customization}\n\n\n          ライブラリは、動作の拡張と変更のための2つの補完的な方法を提供します：\n\n            * 基本コンポーネントのオーバーライド。標準のBlock、Anchor、Connectionのロジックを変更します。\n            * レイヤー（Layers）による拡張。既存のシーンの上/下に根本的に新しい機能を追加します。\n\n          ### コンポーネントのオーバーライド\n\n\n          既存の要素の外観や動作を変更する必要がある場合、基本クラスを継承し、キーメソッドをオーバーライドします。次に、独自の名前でコンポーネントを登録します。\n\n\n          #### ブロックのカスタマイズ\n\n\n          例えば、ブロックにプログレスバーのあるグラフを作成する必要がある場合 — 例えば、パイプラインのタスク実行状態を表示するために — 標準ブロックを簡単にカスタマイズできます：\n\n\n          ```json\n\n          import { CanvasBlock } from \"@gravity‑ui/graph\";\n\n\n          class ProgressBlock extends CanvasBlock {\n            // 角丸の基本ブロック形状\n            public override renderBody(ctx: CanvasRenderingContext2D): void {\n              ctx.fillStyle = \"#ddd\";\n              ctx.beginPath();\n              ctx.roundRect(this.state.x, this.state.y, this.state.width, this.state.height, 12);\n              ctx.fill();\n              ctx.closePath();\n            }\n\n            public renderSchematicView(ctx: CanvasRenderingContext2D): void {\n              const progress = this.state.meta?.progress || 0;\n\n              // ブロックの基本を描画\n              this.renderBody(ctx);\n\n              // 色インジケーション付きプログレスバー\n              const progressWidth = (this.state.width - 20) * (progress / 100);\n              ctx.fillStyle = progress < 50 ? \"#ff6b6b\" : progress < 80 ? \"#feca57\" : \"#48cae4\";\n              ctx.fillRect(this.state.x + 10, this.state.y + this.state.height - 15, progressWidth, 8);\n\n              // プログレスバーのフレーム\n              ctx.strokeStyle = \"#ddd\";\n              ctx.lineWidth = 1;\n              ctx.strokeRect(this.state.x + 10, this.state.y + this.state.height - 15, this.state.width - 20, 8);\n\n              // パーセントと名前のテキスト\n              ctx.fillStyle = \"#2d3436\";\n              ctx.font = \"12px Arial\";\n              ctx.textAlign = \"center\";\n              ctx.fillText(`${Math.round(progress)}%`, this.state.x + this.state.width / 2, this.state.y + 20);\n              ctx.fillText(this.state.name, this.state.x + this.state.width / 2, this.state.y + 40);\n            }\n          }\n\n          ```\n\n\n          #### 接続のカスタマイズ\n\n\n          同様に、接続の動作と外観を変更する必要がある場合 — 例えば、ブロック間のデータフローの強度を表示するために — カスタム接続を作成できます：\n\n\n          ```json\n\n          import { BlockConnection } from \"@gravity-ui/graph\";\n\n\n          class DataFlowConnection extends BlockConnection {\n            public override style(ctx: CanvasRenderingContext2D) {\n              // 接続されたブロックからフローデータを取得\n              const sourceBlock = this.sourceBlock;\n              const targetBlock = this.targetBlock;\n\n              const sourceProgress = sourceBlock?.state.meta?.progress || 0;\n              const targetProgress = targetBlock?.state.meta?.progress || 0;\n\n              // ブロックの進捗に基づいてフロー強度を計算\n              const flowRate = Math.min(sourceProgress, targetProgress);\n              const isActive = flowRate > 10; // 進捗 > 10%でフローがアクティブ\n\n              if (isActive) {\n                // アクティブなフロー -- 太い緑の線\n                ctx.strokeStyle = \"#00b894\";\n                ctx.lineWidth = Math.max(2, Math.min(6, flowRate / 20));\n              } else {\n                // 非アクティブなフロー -- 点線のグレーの線\n                ctx.strokeStyle = \"#ddd\";\n                ctx.lineWidth = this.context.camera.getCameraScale();\n                ctx.setLineDash([5, 5]);\n              }\n\n              return { type: \"stroke\" };\n            }\n          }\n\n          ```\n\n\n          #### カスタムコンポーネントの使用\n\n\n          作成したコンポーネントをグラフ設定に登録します：\n\n\n          ```json\n\n          const customGraph = new Graph({\n            blocks: [\n              {\n                id: \"task1\",\n                is: \"progress\",\n                x: 100,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"データ処理\",\n                meta: { progress: 75 },\n              },\n              {\n                id: \"task2\",\n                is: \"progress\",\n                x: 400,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"分析\",\n                meta: { progress: 30 },\n              },\n              {\n                id: \"task3\",\n                is: \"progress\",\n                x: 700,\n                y: 100,\n                width: 200,\n                height: 80,\n                name: \"出力\",\n                meta: { progress: 5 },\n              },\n            ],\n            connections: [\n              { sourceBlockId: \"task1\", targetBlockId: \"task2\" },\n              { sourceBlockId: \"task2\", targetBlockId: \"task3\" },\n            ],\n            settings: {\n              // カスタムブロックを登録\n              blockComponents: {\n                'progress': ProgressBlock,\n              },\n              // すべての接続にカスタム接続を登録\n              connection: DataFlowConnection,\n              useBezierConnections: true,\n            },\n          });\n\n\n          customGraph.setEntities({\n            blocks: [\n              {\n              is: 'progress',\n              id: '1',\n              name: \"プログレスブロック',\n              x: 10, \n              y: 10, \n              width: 10, \n              height: 10,\n              anchors: [],\n              selected: false,\n              }\n            ]\n          })\n\n\n          customGraph.start();\n\n          ```\n\n\n          #### 結果\n\n\n          結果として得られるグラフでは：\n\n            * ブロックが色インジケーション付きで現在の進捗を表示\n            * 接続がデータフローを可視化：アクティブなフローは緑で太く、非アクティブなフローはグレーで点線\n            * ズーム時にブロックが自動的に完全なインタラクティビティを持つHTMLモードに切り替わる\n\n          ### レイヤーによる拡張\n\n\n          レイヤーは、グラフの「空間」に挿入される追加のCanvasまたはHTML要素です。本質的に、各レイヤーは独自のキャンバス（高速グラフィック用）またはHTMLコンテナ（複雑なインタラクティブ要素用）を含むことができる別個のレンダリングチャネルです。\n\n\n          ちなみに、ライブラリのReact統合はレイヤーを通じて動作します：ReactコンポーネントはReact Portalを通じてHTMLレイヤーにレンダリングされます。\n\n\n          #### レイヤーのアーキテクチャ\n\n\n          レイヤーは、Canvas vs HTMLのジレンマに対するもう1つの重要なソリューションです。レイヤーはCanvasとHTML要素の位置を同期し、それらが互いに正しく重なることを保証します。これにより、単一の空間に留まりながら、CanvasとHTMLをシームレスに切り替えることができます。グラフは、互いに重なる独立したレイヤーで構成されています：\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/canvas-vs-html/pic7.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          レイヤーは2つの座標システムで動作できます：\n\n            * グラフにバインド（`transformByCameraPosition: true`）：\n\n              * 要素がカメラと一緒に移動する\n              * ブロック、接続、グラフ要素\n\n            * 画面に固定（`transformByCameraPosition: false`）：\n\n              * パンしても所定の位置に留まる\n              * ツールバー、凡例、UIコントロール\n\n          #### React統合の仕組み\n\n\n          React統合を持つレイヤーは、レイヤーとは何かを示すのに十分です。まず、カメラの可視領域内にあるブロックのリストを強調するコンポーネントを見てみましょう。このために、カメラの変更を購読し、各変更後にカメラのビューポートと要素のヒットボックスの交差をチェックする必要があります。\n\n\n          ```json\n\n          import { Graph } from \"@gravity-ui/graph\";\n\n\n          const BlocksList = ({ graph, renderBlock }: { graph: Graph,\n          renderBlock: (graph: Graph, block: TBlock) => React.JSX.Element }) =>\n          {\n            const [blocks, setBlocks] = useState([]);\n\n            const updateVisibleList = useCallback(() => {\n              const cameraState = graph.cameraService.getCameraState();\n              const CAMERA_VIEWPORT_TRESHOLD = 0.5;\n              const x = -cameraState.relativeX - cameraState.relativeWidth * CAMERA_VIEWPORT_TRESHOLD;\n              const y = -cameraState.relativeY - cameraState.relativeHeight * CAMERA_VIEWPORT_TRESHOLD;\n              const width = -cameraState.relativeX + cameraState.relativeWidth * (1 + CAMERA_VIEWPORT_TRESHOLD) - x;\n              const height = -cameraState.relativeY + cameraState.relativeHeight * (1 + CAMERA_VIEWPORT_TRESHOLD) - y;\n              \n              const blocks = graph\n                .getElementsOverRect(\n                  {\n                    x,\n                    y,\n                    width,\n                    height,\n                  }, // ブロックリストを検索するエリアを定義\n                  [CanvasBlock] // カメラの可視領域で検索される要素タイプを定義\n                ).map((component) => component.connectedState); // ブロックモデルのリストを取得\n\n                setBlocks(blocks);\n            });\n\n              useGraphEvent(graph, \"camera-change\", ({ scale }) => {\n                if (scale >= 0.7) {\n                  // スケールが0.7以上の場合、ブロックリストを更新\n                  updateVisibleList()\n                  return;\n                }\n                setBlocks([]);\n              });\n\n              return blocks.map(block => <React.Fragment key={block.id}>{renderBlock(graphObject, block)}</React.Fragment>)\n          }\n\n          ```\n\n\n          次に、このコンポーネントを使用するレイヤー自体の説明を見てみましょう。\n\n\n          ```json\n\n          import { Layer } from '@gravity-ui/graph';\n\n\n          class ReactLayer extends Layer {\n            constructor(props: TReactLayerProps) {\n              super({\n                html: {\n                  zIndex: 3, // レイヤーを他のレイヤーの上に上げる\n                  classNames: [\"no-user-select\"], // テキスト選択を無効にするクラスを追加\n                  transformByCameraPosition: true, // レイヤーがカメラにバインド - レイヤーがカメラと一緒に移動\n                },\n                ...props,\n              });\n            }\n\n            public renderPortal(renderBlock: <T extends TBlock>(block: T) => React.JSX.Element) {\n              if (!this.getHTML()) {\n                return null;\n              }\n\n              const htmlLayer = this.getHTML() as HTMLDivElement;\n\n              return createPortal(\n                React.createElement(BlocksList, {\n                  graph: this.context.graph,\n                  renderBlock: renderBlock,\n                }),\n                htmlLayer,\n              );\n            }\n          }\n\n          ```\n\n\n          これでアプリケーションでこのレイヤーを使用できます。\n\n\n          ```json\n\n          import { Flex } from \"@gravity-ui/uikit\";\n\n\n          const graph = useMemo(() => new Graph());\n\n          const containerRef = useRef<HTMLDivElement>();\n\n\n          useEffect(() => {\n              if (containerRef.current) {\n                graph.attach(containerRef.current);\n              }\n\n              return () => {\n                graph.detach();\n              };\n            }, [graph, containerRef]);\n\n\n          const reactLayer = useLayer(graph, ReactLayer, {});\n\n\n          const renderBlock = useCallback((graph, block) => <Block graph={graph}\n          block={block}>{block.name}</Block>)\n\n            return (\n              <div>\n                <div style={{ position: \"absolute\", overflow: \"hidden\", width: \"100%\", height: \"100%\" }} ref={containerRef}>\n                  {graph && reactLayer && reactLayer.renderPortal(renderBlock)}\n                </div>\n              </div>\n            );\n          ```\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          全体的にかなりシンプルです。上記で説明したことは自分で書く必要はありません — すべて書かれており、使用準備が整っています。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 私たちのグラフライブラリ：利点と使い方{#library}\n\n\n          ライブラリの作業を開始したとき、主な質問は：開発者がパフォーマンスと開発の便利さのどちらかを選ぶ必要がないようにするにはどうすればよいかでした。答えはこの選択を自動化することでした。\n\n\n          ### 利点\n\n\n          #### パフォーマンス + 便利さ\n\n\n          [@gravity‑ui/graph](https://github.com/gravity-ui/graph){target=\"_blank\"}は、スケールに応じてCanvasとHTMLを自動的に切り替えます。これは以下を得ることを意味します：\n\n            * 数千の要素を持つグラフで安定した60 FPS\n            * 詳細表示時に豊かなインタラクティビティを持つ本格的なHTMLコンポーネントを使用する機能\n            * レンダリング方法に関係なく統一されたイベントモデル — click、mouseenterはCanvasとHTMLで同じように動作\n\n          #### UIライブラリとの互換性\n\n\n          主な利点の1つは、任意のUIライブラリとの互換性です。チームが使用している場合：\n\n            * Gravity UI\n            * Material‑UI\n            * Ant Design\n            * カスタムコンポーネント\n\n          …それらを放棄する必要はありません！ズームインすると、グラフは自動的にHTMLモードに切り替わり、必要な色テーマでおなじみの`Button`、`Select`、`DatePicker`が通常のReactアプリケーションと同じように動作します。\n\n\n          #### Framework agnostic\n\n\n          Reactを使用して基本的なHTMLレンダラーを実装しましたが、ライブラリがframework-agnosticであるように開発しました。これは、必要に応じてお気に入りのフレームワークの統合を持つレイヤーを非常に簡単に実装できることを意味します。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## 代替品はあるか？{#analogs}\\n\\n現在、市場にはグラフ描画のためのソリューションがかなり多くあります。[yFiles](https://yfiles.dev/){target=\\\"_blank\\\"}、[JointJS](https://github.com/clientIO/joint){target=\\\"_blank\\\"}などの有料ソリューションから、[Foblex Flow](https://github.com/Foblex/f-flow){target=\\\"_blank\\\"}、[baklavajs](https://github.com/newcat/baklavajs){target=\\\"_blank\\\"}、[jsPlumb](https://github.com/jsplumb/community-edition){target=\\\"_blank\\\"}などのオープンソースソリューションまで。しかし、比較のために最も人気のあるツールとして[@antv/g6](https://github.com/antvis/G6){target=\\\"_blank\\\"}と[React Flow](https://github.com/xyflow/xyflow){target=\\\"_blank\\\"}を検討しています。それぞれに特徴があります。\\n\\nReact Flow — ノードベースのインターフェース構築に適した良いライブラリです。多くの機能がありますが、svgとhtmlを使用しているため、パフォーマンスはかなり控えめです。グラフが100-200ブロックを超えないことが確実な場合には良いライブラリです。\\n\\n一方、@antv/g6には多くの機能があり、Canvas、特にWebGLをサポートしています。@antv/g6と@gravity‑ui/graphを直接比較することはおそらくできません：彼らはより多くのグラフやダイアグラムの構築に焦点を当てています — しかし、ノードベースのUIもサポートされています。したがって、ノードベースのインターフェースだけでなく、チャートを描くことも重要な場合は、antv/g6が適しています。\\n\\n@antv/g6ライブラリはcanvas/webglとhtml/svgの両方ができますが、切り替えルールの管理は手動で行う必要があり、正しく行う必要があります。パフォーマンスはReact Flowよりもはるかに速いですが、ライブラリにはまだ疑問があります。WebGLサポートがあると主張されていますが、[ストレステスト](https://g6.antv.antgroup.com/en/examples/performance/massive-data#60000){target=\\\"_blank\\\"}を見ると、60kノードでライブラリがダイナミクスを提供できないことがわかります — MacBook M3で1フレームのレンダリングに4秒かかりました。比較のために、同じMacbook M3での111kノードと109k接続を持つ私たちの[ストレステスト](https://preview.gravity-ui.com/graph/?path=/story/stories-main-grapheditor--graph-stress-test){target=\\\"_blank\\\"}：グラフ全体のシーンのレンダリングに約60msかかり、約15-20FPSを提供します。これはそれほど多くありませんが、Spatial Cullingを考慮すると、ビューポートを制限してレスポンシブ性を向上させることができます。メンテナーは100kノードを30 FPSでレンダリングすることを[主張](https://github.com/antvis/G6/issues/1597){target=\\\"_blank\\\"}していましたが、どうやらそれはまだ達成されていないようです。\\n\\n@gravity‑ui/graphが勝っているもう1つのポイントはバンドルサイズです。\\n\\n#|\\n|||バンドルサイズ Minified|バンドルサイズ Minified + Gzipped||\\n||@antv/g6 [bundlephobia](https://bundlephobia.com/package/@antv/g6@5.0.49){target=\\\"_blank\\\"}|1.1 MB|324.5\\_kB||\\n||react flow [bundlephobia](https://bundlephobia.com/package/@xyflow/react@12.8.1){target=\\\"_blank\\\"}|181.2\\_kB|56.4\\_kB||\\n||@gravity-ui/graph [bundlephobia](https://bundlephobia.com/package/@gravity-ui/graph){target=\\\"_blank\\\"}|2.2\\_kB|672\\_B||\\n|#\\n\\n両方のライブラリはパフォーマンスまたは統合の便利さにおいてかなり強力ですが、@gravity‑ui/graphにはいくつかの利点があります — ライブラリは本当に大きなグラフでパフォーマンスを確保し、ユーザーのためにUI/UXを維持し、開発を簡素化できます。\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 今後の計画{#future}\n\n\n          現在、ライブラリにはほとんどのタスクに十分なパフォーマンスの余裕があるため、近い将来、ライブラリ周りのエコシステムの開発にもっと注意を払います — レイヤー（プラグイン）の開発、他のライブラリやフレームワーク（Angular/Vue/Svelte、...など）の統合の追加、タッチデバイスのサポート、モバイルブラウザへの適応、全体的なUX/DXの改善を行います。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 試して参加してください{#try}\n\n\n          [リポジトリ](https://github.com/gravity-ui/graph){target=\"_blank\"}には完全に動作するライブラリがあります：\n\n            * Canvas + R‑Treeのコア（約30K行のコード）\n            * React統合\n            * サンプル付きStorybook\n\n          ライブラリは1行でインストールできます：\n\n\n          `npm install @gravity-ui/graph`\n\n\n          --------------\n\n\n          現在@gravity‑ui/graphと呼ばれているライブラリは、かなり長い間Nirvana内の内部ツールでしたが、選択されたアプローチは十分に実証されました。今、私たちは開発を共有し、外部の開発者がより簡単に、より速く、より効率的にグラフを描くのを助けたいと思っています。\n\n\n          オープンソースコミュニティで複雑なグラフを表示するアプローチを標準化したいと思っています — あまりにも多くのチームが車輪の再発明をしているか、不適切なツールに苦しんでいます。\n\n\n          そのため、フィードバックを収集することは非常に重要です — 異なるプロジェクトは異なるエッジケースをもたらし、ライブラリを発展させることができます。これにより、ライブラリを改善し、Gravity UIエコシステムをより早く成長させることができます。\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
    "title": "",
    "noIndex": false,
    "shareTitle": null,
    "shareDescription": null,
    "shareImage": null,
    "pageLocaleId": null,
    "author": "timofeyevvv",
    "metaDescription": null,
    "keywords": [],
    "shareGenTitle": null,
    "canonicalLink": null,
    "sharingType": "auto",
    "sharingTheme": "light",
    "comment": "initial",
    "shareImageUrl": "https://storage.cloud-preprod.yandex.net/ui-api-ru-preprod-stable-share-generator-screenshots/cache/292d9f3e0a443a096ee408a6f28fc6fec674eb78.png",
    "pageRegionId": 75,
    "summary": null,
    "versionId": 199,
    "service": null,
    "solution": null,
    "locales": [
      {
        "id": 75,
        "pageId": 71,
        "locale": "ru",
        "createdAt": "2026-01-15T11:26:48.440Z",
        "updatedAt": "2026-01-15T11:26:48.519Z",
        "publishedVersionId": null,
        "lastVersionId": 195
      },
      {
        "id": 76,
        "pageId": 71,
        "locale": "en",
        "createdAt": "2026-01-15T11:26:48.532Z",
        "updatedAt": "2026-01-15T11:26:48.609Z",
        "publishedVersionId": null,
        "lastVersionId": 196
      }
    ],
    "pageRegions": [
      {
        "regionCode": "en",
        "publishedVersionId": null
      },
      {
        "regionCode": "ru-ru",
        "publishedVersionId": 199
      }
    ],
    "searchCategory": {
      "id": 7,
      "slug": "blog",
      "title": "ブログ",
      "url": "/blog"
    },
    "voiceovers": []
  }
  