{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:58:27.903Z",
  "updatedAt": "2026-01-27T13:58:27.903Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "ja",
  "publishedVersionId": 269,
  "lastVersionId": 269,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **イリヤ・ロムテフ**\n\n          フロントエンド開発者\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          この記事の内容：\n\n            - [AIKitを作った理由](#why)\n            - [AIKitのアーキテクチャ：何を基盤としたか](#architecture)\n            - [自分のチャットを構築する方法](#how)\n            - [AIKitがサービスに与えた影響](#influence)\n            - [今後の計画](#further)\n            - [AIKitを試す方法](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n昨年、AIアシスタントのブームを目の当たりにしました。これはYandex\\_Cloudのインターフェースにも影響を与えました：テクニカルサポートにモデル付きのチャットボットが登場し、コンソールには作業操作用のエージェントが登場しました。チームはモデルを接続し、ダイアログロジックを考え、デザインを描き、チャットを組み立てていました — そしてこれらすべてを別々に行っていました。\\n\\nさまざまなチームが共通のフレームワークGravity UIでインターフェースを構築していましたが、そこには非常に多くのバリエーションが生まれ、統一されたユーザー体験を維持することが困難になりました。また、同僚たちは同じ解決策に時間を費やしていることに気づき始めました。\\n\\n毎回車輪の再発明をやめるために、蓄積されたプラクティスを統一されたアプローチにまとめ、AIを使ったチャットボット用のツール — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}を作りました。これにより、数日で本格的なアシスタントインターフェースを作成し、さまざまなシナリオに簡単に適応できます。\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n私はイリヤ・ロムテフ、Yandex\\_CloudのFoundation Servicesチームのシニア開発者です。この記事では、AIKitを作ることにした理由、その構造、将来の計画、そして自分で試せることについてお話しします。\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## AIKitを作った理由{#why}\\n\\n昨年、Yandex\\_CloudではAIアシスタントを持つサービスの数が増加しました。例えば：\\n\\n  * SourceCraftのCode Assistant Chat — アシスタントは開発者がコードを書くのを助け、AIエージェントモードではリポジトリを作成・設定し、CI/CDプロセスを起動し、ドキュメントに関する質問に答え、タスクを自動化します。また、issue、プルリクエストを管理し、コードを操作：説明、ファイルの作成と編集ができます。\\n\\n  * クラウドコンソールのAIアシスタント — Yandex\\_Cloudのリソース管理用に開発されたアシスタントです。主なタスクは、APIやツールとのインタラクションの複雑さを隠しながら、クラウドインフラストラクチャを迅速かつ安全に設定、変更、管理することです。\\n\\nエコシステムには数十のチャットが登場し、それぞれが独自のロジック、メッセージフォーマット、コーナーケースのセットを持っていました。\\n\\nチームは大体同じタスクセットに行き着くことがわかりました。ほとんどが必要としているもの：\\n\\n  * ユーザーとアシスタントのメッセージをきれいに表示する\\n\\n  * レスポンスのストリーミングを正しく整理する\\n\\n  * 「アシスタントが入力中」インジケーターを表示する\\n\\n  * 接続切断やリトライなどのエラーを処理する\\n\\nタスクは本質的に同じですが、解決策は多く、UXも異なります。例えば、チャット履歴の配置と表示方法：メニューとして開く別の画面でも、ポップアップのチャットリストでも可能です。\\n\\n問題が明らかになりました：異なるチャットでの体験が大きく異なっていました。あるところではアシスタントがレスポンスをストリーミングし、別のところでは完成したテキストをすぐに表示していました。あるインターフェースではメッセージがグループ化され、別のところでは連続したフィードでした。これが共通のUXを壊していました — ユーザーは同じエコシステムの製品間を移動しているのに、アシスタントからの感覚がまったく異なっていました。\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: AIKitで構築されたライトテーマのチャット例\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          また、モデルに新機能をロールアウトすることがますます困難になっていることに気づきました。ツール、マルチモーダリティ、ツールの構造化されたレスポンスなどをユーザーに届けるには、コントラクトを合意し、バックエンドを改善し、各チームで別々にUIを更新する必要がありました。このような状況では、変更に時間がかかり、スケールしにくかったのです。\n\n\n          この変動の成長を止め、予測可能性を取り戻したいと思いました。そのためには、データモデルと作業パターンを統一し、チームがゼロから始める必要がないように既製のコンポーネントとフックを提供し、シナリオは人それぞれ異なるためカスタマイズの余地を残す必要がありました。\n\n\n          こうして、別ライブラリ@gravity‑ui/aikitのアイデアに至りました — これはGravity UIの拡張で、同じ原則に従いながら、モダンなAIシナリオ：ダイアログ、アシスタント、マルチモーダリティに焦点を当てています。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## AIKitのアーキテクチャ：何を基盤としたか{#architecture}\\n\\nAIKitを設計する際、[AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"}の経験といくつかの基本原則を参考にしました。\\n\\n**基盤としてのAtomic Design**：ライブラリ全体がアトムからページへと構築されています。このような構造は明確な階層を提供し、コンポーネントの再利用を可能にし、必要に応じてどのレベルでも動作を変更できます。\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**完全にSDK非依存**：AIKitは特定のAIプロバイダーに依存しません。OpenAI、Alice\\_AI LLM、または独自のバックエンドを使用できます — UIはpropsを通じてデータを受け取り、状態とリクエストは製品側に残ります。\\n\\n**複雑なシナリオ用の2つの使用レベル**：「箱から出してすぐ使える」既製コンポーネントと、UIを完全にコントロールできるロジック付きフックがあります。例えば、`PromptInput`を使用するか、`usePromptInput`をベースに独自の入力フィールドを構築できます。これにより、基盤を書き直す必要なく柔軟性が得られます。\\n\\n**拡張可能な型システム**。統一性と型安全性を確保するために、拡張可能なデータモデルを収集しました。メッセージは統一された型付き構造で表現されます：ユーザーメッセージ、アシスタントメッセージ、およびいくつかの基本コンテンツタイプ — テキスト（`text`）、モデルの思考（`thinking`）、ツール（`tool`）。また、`MessageRendererRegistry`を通じて独自のタイプを追加できます。\\n\\nこれはすべてTypeScriptで型付けされており、複雑なシナリオをより早く組み立て、開発段階でエラーを回避するのに役立ちます。\\n\\n```javascript\\n// 1. データ型を定義\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. 表示コンポーネントを作成\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>チャートの可視化: {part.data.chartType}</div>;\\n};\\n// 3. レンダラーを登録\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. AssistantMessageで使用\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\n最後に、CSS変数によるテーマ設定、i18n（RU/EN）の追加、アクセシビリティ（ARIA、キーボードナビゲーション）の確保、DockerでのPlaywright Component Testingによる視覚的回帰テストの設定を行い、ライブラリは本番環境での使用準備が整いました。\\n\\n### 内部構造\\n\\nAIKitの基盤は、統一されたダイアログモデルです。これを作成するために、まずメッセージの階層を理解する必要がありました。\\n\\nメッセージ自体はかなり多面的なエンティティです。LLMからの最初のメッセージは1つのストリームです。しかし、その中には多くの異なるネストされたメッセージがあり得ます：本質的に、これらは1つの質問を解決するための推論、提案、ツール呼び出しです。これらすべての異なるサブメッセージは、実際にはバックエンドからの1つのメッセージです。しかし、それぞれがシンプルなLLM使用では別個のメッセージになり得ます。\\n\\nそのため、チャットを両方の方法で使用できるようにしました：メッセージは互いにネストすることも、フラットにすることもできます — ここではすべてニーズ次第です。\\n\\n状態管理はサービス側に残ります。AIKitは自身でデータを保存しません — 外部から受け取ります。チームはReact State、Redux、Zustand、Reatomなど、便利なものを使用できます。私たちは典型的なUIロジックをカプセル化するフックを提供するだけです。例えば：\\n\\n  * `useSmartScroll`によるスマートスクロール\\n\\n  * 日付の操作、例えばロケールを考慮した日付フォーマット`useDateFormatter`\\n\\n  * ツールメッセージの処理`useToolMessage`\\n\\n  * ダイアログ構築に必要なその他すべて\\n\\nこれに加えて、AIKitは拡張可能なままです。任意のモデルを接続し、独自のコンテンツタイプを作成し、タスクに完全に合わせてUIを構築できます — フックのロジックを使用するか、既製のコンポーネントをベースとして使用します。アーキテクチャにより、共通の原則を壊すことなく実験できます。\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 自分のチャットを構築する方法{#how}\n\n\n          最初のチャットを作成するには、準備されたChatContainerコンポーネントを使用します：\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // メッセージ送信ロジック\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // 状態を更新\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'メッセージを入力するか、提案を選択して会話を開始してください。',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: '試してみてください：',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: '量子コンピューティングを簡単に説明してください'\n                  },\n                  {\n                    id: '2',\n                    title: '自然についての詩を書いてください'\n                  },\n                  {\n                    id: '3',\n                    title: 'JavaScriptコードのデバッグを手伝ってください'\n                  },\n                  {\n                    id: '4',\n                    title: '最近のAI開発を要約してください'\n                  }\n                ],\n                title: 'AIチャットへようこそ'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          「箱から出して」すべてがこのように見えます：\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          少し楽しさを加えましょう：\n\n\n          1. 初期状態を修正します。\n\n              より細かい設定のために、個別のコンポーネントからチャットを組み立てます：`Header`、`MessageList`、`PromptBox`。\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AIアシスタント\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"何でも質問してください...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. `MessageType`を通じてインポートされた異なる組み込みメッセージタイプを適用します。\n\n              * `thinking` — AIの思考プロセスを表示します（これにより、ユーザーはアシスタントが回答を準備するロジックを調べることができます）。\n\n              * `tool` — インタラクティブなレスポンスブロックの表示に適しています。私たちのケースでは、構文ハイライトが正しく機能し、編集とクリップボードへのコピー操作がサポートされているコードブロックです。\n\n              また、独自のタイプを追加できます。例えば、画像付きメッセージ：\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. CSSでスタイリングを追加します…\n\n              …そしてサンタクロースとのチャットができあがります :)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          個々の要素を完全にカスタマイズするには、フックを使用できます — 記事へのコメントであなたのスタイリングバリエーションを見せていただけると嬉しいです！\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## AIKitがサービスに与えた影響{#influence}\\n\\nYandex\\_CloudでAIKitを使用した結果はすぐに現れました。すべてのサービスでアシスタントが同じように動作するようになりました：同じようにレスポンスをストリーミングし、同じようにエラーを表示し、同じようにメッセージをグループ化します。UXが統一され、エコシステム全体でのインタラクションがより簡単になり、動作がより期待通りで予測可能になりました。\\n\\n  * UX言語が統一されました — 異なる製品のアシスタントチャットが同じエコシステムの一部として感じられるようになりました。ユーザーは予測可能な動作を見ます：同一のストリーミング、エラー処理、インタラクションパターン。\\n\\n  * チャットUIの開発速度が大幅に向上しました。\\n\\n  * 集中化された開発 — thinkingコンテンツタイプやツールとの改善された連携などの新機能は一度追加され、自動的にすべてで利用可能になります。\\n\\n  * ライブラリはエコシステム内のAIインターフェース標準を形成する基盤となりました。\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## 今後の計画{#further}\n\n\n          計画についてお話しします。いくつかの方向性を特定しました：\n\n            * 非常に大きなチャット履歴を扱うための仮想化によるパフォーマンス向上。\n\n            * 積極的に発展しているAIエージェントの新機能に対応する基本シナリオの拡張。\n\n            * 人気のあるAIモデルのデータをチャットデータモデルにマッピングするのを簡素化するユーティリティの追加。\n\n          さらに、ドキュメントと例を発展させていきます。そしてもちろん、コミュニティの発展 — ライブラリが社内だけでなく外部の開発者にも役立つことを望んでいます。\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## AIKitを試す方法{#try}\n\n\n          当サイトの[ライブラリセクション](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}をご覧ください。独自のAIアシスタントを作成していて、高速で予測可能なチャットインターフェースが必要で、すでにGravity UIを使用している（または試す準備ができている）場合は、READMEと例をご覧ください。フィードバックをいただけると嬉しいです — issueを作成し、PRを送り、あなたのシナリオに他に何が必要か教えてください！\n\n\n          プロジェクトが気に入ったら、[AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"}と[UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"}に⭐️をいただけると嬉しいです！\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "add sharing",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 116,
  "summary": null,
  "versionId": 269,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "ru",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "en",
      "publishedVersionId": 268
    },
    {
      "regionCode": "ru-ru",
      "publishedVersionId": 269
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "ブログ",
    "url": "/blog"
  },
  "voiceovers": []
}