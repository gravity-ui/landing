{
  "id": 108,
  "name": "blog/gravityui-aikit",
  "createdAt": "2026-01-27T13:57:57.515Z",
  "updatedAt": "2026-01-27T13:57:57.515Z",
  "type": "default",
  "isDeleted": false,
  "versionOnTranslationId": null,
  "searchCategorySlug": "blog",
  "regions": [],
  "pageId": 108,
  "regionCode": "en",
  "publishedVersionId": 268,
  "lastVersionId": 268,
  "content": "blocks:\n  - type: blog-header-block\n    resetPaddings: true\n    paddingBottom: l\n    width: m\n    verticalOffset: m\n    theme: dark\n    background:\n      image:\n        src: >-\n          https://storage.yandexcloud.net/gravity-landing-static/blog/blog-cover-bg.png\n        disableCompress: true\n      color: '#2A1A2A'\n      fullWidth: false\n  - type: blog-layout-block\n    resetPaddings: true\n    mobileOrder: reverse\n    children:\n      - type: blog-yfm-block\n        resetPaddings: true\n        column: right\n        text: >\n\n          ![image](https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/speaker.jpg\n          =80x)\n\n\n          **Ilja Lomtev**\n\n          Frontend-Entwickler\n      - type: blog-yfm-block\n        column: right\n        resetPaddings: true\n        text: |\n\n          In diesem Artikel:\n\n            - [Wie und warum wir AIKit entwickelt haben](#why)\n            - [AIKit-Architektur: worauf wir aufgebaut haben](#architecture)\n            - [Wie man seinen eigenen Chat baut](#how)\n            - [Wie AIKit die Services beeinflusst hat](#influence)\n            - [Was als Nächstes kommt](#further)\n            - [Wie man AIKit ausprobieren kann](#try)\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nIm letzten Jahr beobachten wir einen Boom von KI-Assistenten — und das ging auch an den Interfaces in Yandex\\_Cloud nicht vorbei: mal tauchte im Support ein Chatbot mit einem Modell auf, mal in der Konsole ein Agent für operative Aufgaben. Teams haben Modelle angebunden, Dialoglogik durchdacht, Design entworfen und Chats gebaut — und das alles jeweils für sich.\\n\\nVerschiedene Teams haben Interfaces auf dem gemeinsamen Framework Gravity UI aufgebaut, aber nach und nach entstanden so viele Varianten, dass es schwierig wurde, ein einheitliches Nutzererlebnis zu unterstützen. Außerdem stießen Kolleginnen und Kollegen immer häufiger darauf, dass sie Zeit in immer dieselben Lösungen investierten.\\n\\nDamit wir nicht jedes Mal das Rad neu erfinden, haben wir die gesammelten Praktiken in einem einheitlichen Ansatz gebündelt und ein Tool für KI-Chatbots entwickelt — [@gravity‑ui/aikit](https://github.com/gravity-ui/aikit){target=\\\"_blank\\\"}. Damit lässt sich in wenigen Tagen ein vollwertiges Assistenten-Interface erstellen, das sich zugleich leicht an unterschiedliche Szenarien anpassen lässt.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic0.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\nMein Name ist Ilja Lomtev, ich bin Senior Developer im Team Foundation Services von Yandex\\_Cloud. In diesem Artikel erzähle ich, warum wir uns entschieden haben, AIKit zu bauen, wie es aufgebaut ist, ein wenig über unsere Zukunftspläne — und darüber, was ihr selbst ausprobieren könnt.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Wie und warum wir AIKit entwickelt haben{#why}\\n\\nIm letzten Jahr ist in Yandex\\_Cloud die Zahl der Services mit KI-Assistenten gewachsen, zum Beispiel: \\n\\n  * Code Assistant Chat in SourceCraft — der Assistent hilft Entwicklern beim Schreiben von Code und erstellt bzw. konfiguriert im KI-Agentenmodus Repositories, startet CI/CD-Prozesse, beantwortet Fragen zur Dokumentation und automatisiert Aufgaben. Er kann außerdem Issues und Pull Requests verwalten und mit Code arbeiten: erklären, Dateien erstellen und bearbeiten.\\n\\n  * KI-Assistent in der Cloud-Konsole — ein Assistent, der für die Verwaltung von Ressourcen in Yandex\\_Cloud entwickelt wurde. Hauptaufgabe ist es, die Cloud-Infrastruktur schnell und sicher zu konfigurieren, zu ändern und zu verwalten, indem die Komplexität der Interaktion mit API und Tools verborgen wird.\\n\\nIm Ökosystem entstanden etwa ein Dutzend Chats, jeder mit eigener Logik, eigenem Nachrichtenformat und einem eigenen Satz an Corner Cases. \\n\\nWir haben festgestellt, dass Teams auf ungefähr denselben Satz an Aufgaben stoßen. Was die meisten brauchen: \\n\\n  * Nachrichten von Nutzer und Assistent sauber darstellen, \\n\\n  * das Streaming von Antworten korrekt organisieren, \\n\\n  * den Indikator „Assistent tippt“ anzeigen, \\n\\n  * Fehler wie eine abgebrochene Verbindung oder Retries behandeln. \\n\\nDie Aufgaben sind im Kern gleich, aber es gibt viele Lösungswege — und der UX unterscheidet sich. Zum Beispiel die Position und Art der Anzeige der Chat-Historie: das kann ein separater Screen sein, der sich wie ein Menü öffnet, oder eine Chat-Liste in einem Popup.\\n\\nEin Problem trat zutage: Die Erfahrung in den verschiedenen Chats unterschied sich deutlich. An manchen Stellen streamte der Assistent die Antwort, an anderen wurde sofort der fertige Text angezeigt. In einem Interface wurden Nachrichten gruppiert, in einem anderen liefen sie als durchgehender Feed. Das brach den gemeinsamen UX — der Nutzer wechselt zwischen Produkten desselben Ökosystems, aber das Gefühl beim Assistenten ist völlig unterschiedlich.   \\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: Beispiele für mit AIKit erstellte Chats im hellen Theme\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic1.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Außerdem wurde deutlich, dass es immer schwieriger wurde, neue Features\n          in den Modellen auszurollen. Um Nutzern z. B. Tool-Fähigkeiten,\n          Multimodalität oder strukturierte Tool-Antworten zugänglich zu machen,\n          musste man den Vertrag abstimmen, Backends nachrüsten und danach den UI\n          in jedem Team separat aktualisieren. Unter solchen Bedingungen dauerten\n          Änderungen lange und ließen sich schlecht skalieren.\n\n\n          Wir wollten dieses Wachstum an Variabilität stoppen und wieder\n          Vorhersehbarkeit herstellen. Dafür mussten wir das Datenmodell und die\n          Arbeitsmuster vereinheitlichen, fertige Komponenten und Hooks liefern,\n          damit Teams nicht bei null anfangen müssen, und Raum für Customization\n          lassen — denn die Szenarien sind bei allen unterschiedlich. \n\n\n          So kamen wir zur Idee einer eigenen Bibliothek @gravity‑ui/aikit — eine\n          Erweiterung von Gravity UI, die denselben Prinzipien folgt, aber auf\n          moderne KI-Szenarien ausgerichtet ist: Dialoge, Assistenten,\n          Multimodalität.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## AIKit-Architektur: worauf wir aufgebaut haben{#architecture}\\n\\nBeim Entwurf von AIKkit haben wir uns am Erfahrungswissen von [AI\\_SDK](https://ai-sdk.dev/){target=\\\"_blank\\\"} und an einigen grundlegenden Prinzipien orientiert.\\n\\n**Atomic Design als Grundlage**: Die gesamte Bibliothek wird von Atomen bis hin zu Seiten aufgebaut. Diese Struktur gibt eine klare Hierarchie, ermöglicht die Wiederverwendung von Komponenten und erlaubt bei Bedarf, Verhalten auf jeder Ebene zu ändern.\\n\"\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic2.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n**Vollständig SDK-agnostisch**: AIKit hängt nicht von einem konkreten KI-Provider ab. Man kann OpenAI, Alice\\_AI LLM oder das eigene Backend verwenden — der UI nimmt Daten über Props entgegen, während State und Requests auf der Produktseite bleiben. \\n\\n**Zwei Nutzungsebenen für komplexe Szenarien**: Es gibt eine fertige Komponente, die „out of the box“ funktioniert, und es gibt einen Hook mit Logik, der eine vollständige Kontrolle über den UI erlaubt. Zum Beispiel kann man `PromptInput` verwenden oder ein eigenes Eingabefeld auf Basis von `usePromptInput` bauen. Das gibt Flexibilität, ohne das Fundament neu schreiben zu müssen.\\n\\n**Erweiterbares Typ-System**. Um Einheitlichkeit und Typsicherheit zu gewährleisten, haben wir ein erweiterbares Datenmodell zusammengestellt. Nachrichten werden durch eine einheitliche typisierte Struktur abgebildet: Es gibt Nutzernachrichten, Assistentennachrichten und mehrere Basistypen von Content — Text (`text`), Modell-Überlegungen (`thinking`), Tools (`tool`). Gleichzeitig kann man eigene Typen über `MessageRendererRegistry` hinzufügen. \\n\\nAlles ist in TypeScript typisiert, was hilft, komplexe Szenarien schneller zu bauen und Fehler schon in der Entwicklungsphase zu vermeiden.\\n\\n```javascript\\n// 1. Datentyp definieren\\ntype ChartMessageContent = TMessageContent<\\n    'chart',\\n    {\\n        chartData: number[];\\n        chartType: 'bar' | 'line';\\n    }\\n>;\\n// 2. Darstellungskomponente erstellen\\nconst ChartRenderer = ({part}: MessageContentComponentProps<ChartMessageContent>) => {\\n    return <div>Diagramm-Visualisierung: {part.data.chartType}</div>;\\n};\\n// 3. Renderer registrieren\\nconst customRegistry = registerMessageRenderer(createMessageRendererRegistry(), 'chart', {\\n    component: ChartRenderer,\\n});\\n// 4. In AssistantMessage verwenden\\n<AssistantMessage message={message} messageRendererRegistry={customRegistry} />;\\n```\\n\\nSchließlich haben wir Theming über CSS-Variablen vorgesehen, i18n (RU/EN) hinzugefügt, Barrierefreiheit sichergestellt (ARIA, Tastaturnavigation) und visuelle Regressionstests über Playwright Component Testing in Docker eingerichtet — und die Bibliothek war bereit für den Produktionseinsatz.\\n\\n### Was unter der Haube steckt \\n\\nDie Basis von AIKit ist ein einheitliches Dialogmodell. Um es zu erstellen, mussten wir zunächst die Hierarchie der Nachrichten verstehen. \\n\\nNachrichten sind an sich recht vielschichtige Entitäten. Es gibt die erste Nachricht vom LLM — das ist ein Stream. Innerhalb davon kann es jedoch viele verschiedene verschachtelte Nachrichten geben: im Grunde sind das Überlegungen, Vorschläge, Tool-Calls zur Lösung einer Frage. All diese unterschiedlichen Teilnachrichten sind faktisch eine Nachricht vom Backend. Gleichzeitig kann jede davon bei einer einfachen Nutzung eines LLM durchaus eine separate Nachricht sein. \\n\\nDeshalb haben wir die Möglichkeit gelassen, den Chat auf beide Arten zu verwenden: Nachrichten können ineinander verschachtelt sein oder flach — das hängt vom Bedarf ab.\\n\\nDas State-Management bleibt dabei beim Service. AIKit speichert Daten nicht selbst — es nimmt sie von außen entgegen. Teams können React State, Redux, Zustand, Reatom verwenden — alles, was passt. Wir liefern lediglich Hooks, die typische UI-Logik kapseln, zum Beispiel: \\n\\n  * intelligentes Scrollen mit `useSmartScroll`;\\n\\n  * Arbeit mit Datumswerten, z. B. datumsformatierung unter Berücksichtigung der Locale mit `useDateFormatter`; \\n\\n  * Verarbeitung von Tool-Nachrichten mit `useToolMessage`;\\n\\n  * und alles Weitere, was man zum Aufbau eines Dialogs braucht.\\n\\nZusätzlich bleibt AIKit erweiterbar. Man kann beliebige Modelle anbinden, eigene Content-Typen erstellen und den UI vollständig nach den eigenen Aufgaben bauen — entweder mit der Logik aus den Hooks oder indem man fertige Komponenten als Basis nutzt. Die Architektur erlaubt Experimente, ohne die gemeinsamen Prinzipien zu verletzen.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Wie man seinen eigenen Chat baut{#how}\n\n\n          Für die Erstellung unseres ersten Chats nutzen wir die vorbereitete\n          Komponente ChatContainer:\n\n\n          ```javascript\n\n          import React, { useState } from 'react';\n\n          import { ChatContainer } from 'aikit';\n\n          import type { ChatType, MessageType } from 'aikit';\n\n\n          function App() {\n              const [messages, setMessages] = useState<MessageType[]>([]);\n              const [chats, setChats] = useState<ChatType[]>([]);\n              const [activeChat, setActiveChat] = useState<ChatType | null>(null);\n\n              const handleSendMessage = async (content: string) => {\n                  // Your message sending logic\n                  const response = await fetch('/api/chat', {\n                      method: 'POST',\n                      body: JSON.stringify({ message: content })\n                  });\n                  const data = await response.json();\n\n                  // Update state\n                  setMessages(prev => [...prev, data]);\n              };\n\n              return (\n            <ChatContainer\n              messages={[]}\n              onSendMessage={() => {}}\n              welcomeConfig={{\n                description: 'Start a conversation by typing a message or selecting a suggestion.',\n                image: <Icon data={() => {}} size={48}/>,\n                suggestionTitle: 'Try asking:',\n                suggestions: [\n                  {\n                    id: '1',\n                    title: 'Explain quantum computing in simple terms'\n                  },\n                  {\n                    id: '2',\n                    title: 'Write a poem about nature'\n                  },\n                  {\n                    id: '3',\n                    title: 'Help me debug my JavaScript code'\n                  },\n                  {\n                    id: '4',\n                    title: 'Summarize recent AI developments'\n                  }\n                ],\n                title: 'Welcome to AI Chat'\n              }}\n          />\n                  \n              );\n          }\n\n          ```\n\n\n          „Out of the box“ sieht das so aus:\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic3.png\n        fullscreen: true\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          Fügen wir etwas Feststimmung hinzu: \n\n\n          1. Passen wir den initialen State an. \n\n              Für eine feinere Konfiguration bauen wir den Chat aus einzelnen Komponenten: `Header`, `MessageList`, `PromptBox`.\n\n              ```javascript\n              import { Header, MessageList, PromptBox } from 'aikit';\n              function CustomChat() {\n                  return (\n                      <div className=\"custom-chat\">\n                          <Header title=\"AI Assistant\" onNewChat={() => {}} />\n                          <MessageList messages={messages} showTimestamp />\n                          <PromptBox onSend={handleSend} placeholder=\"Fragen Sie irgendetwas...\" />\n                      </div>\n                  );\n              }\n              ```\n\n          2. Verwenden wir verschiedene eingebaute Nachrichtentypen, importiert über\n          `MessageType`.\n\n              * `thinking` — zeigt den Denkprozess der KI (so kann der Nutzer die Logik nachvollziehen, nach der der Assistent die Antwort vorbereitet).\n\n              * `tool` — eignet sich zur Darstellung interaktiver Antwortblöcke; in unserem Fall ist das ein Code-Block, in dem Syntax-Highlighting korrekt funktioniert und Bearbeiten sowie Kopieren in die Zwischenablage unterstützt werden.\n\n              Außerdem kann man eigene Typen hinzufügen, zum Beispiel Nachrichten mit Bildern:\n\n\n              ```javascript\n              type ImageMessage = BaseMessage<ImageMessageData> & { type: 'image' };\n\n\n              const ImageMessageView = ({ message }: { message: ImageMessage }) => (\n                  <div>\n                      <img src={message.data.imageUrl} />\n                      {message.data.caption && <p>{message.data.caption}</p>}\n                  </div>\n              );\n\n\n              const customTypes: MessageTypeRegistry = {\n                  image: {\n                      component: ImageMessageView,\n                      validator: (msg) => msg.type === 'image'\n                  }\n              };\n\n\n              <ChatContainer messages={messages} messageTypeRegistry={customTypes} />\n              ```\n\n          3. Fügen wir Styling via CSS hinzu…\n\n              …und erhalten einen Chat mit Väterchen Frost:)\n      - type: blog-media-block\n        column: left\n        resetPaddings: true\n        text: ''\n        image:\n          src: >-\n            https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/pic4.png\n        fullscreen: true\n      - type: blog-colored-text-block\n        column: left\n        resetPaddings: true\n        size: l\n        background:\n          color: '#CCD9FF'\n        text: >\n\n          Für die vollständige Anpassung einzelner Elemente kann man Hooks\n          verwenden — wir freuen uns, eure Styling-Varianten in den Kommentaren\n          unter dem Artikel zu sehen!\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: \"\\n## Wie AIKit die Services beeinflusst hat{#influence}\\n\\nDas Ergebnis der Nutzung von AIKit in Yandex\\_Cloud wurde schnell sichtbar. In allen Services begannen sich die Assistenten gleich zu verhalten: Antworten gleich zu streamen, Fehler gleich anzuzeigen, Nachrichten gleich zu gruppieren. Der UX wurde einheitlich; jetzt lässt er sich im gesamten Ökosystem leichter nutzen, das Verhalten ist erwartbarer und vorhersehbarer.\\n\\n  * Die UX-Sprache ist einheitlich geworden — Assistenten-Chats in verschiedenen Produkten fühlen sich jetzt wie Teil eines einzigen Ökosystems an. Nutzer sehen vorhersehbares Verhalten: identisches Streaming, Fehlerbehandlung, Interaktionsmuster. \\n\\n  * Die Entwicklungsgeschwindigkeit des Chat-UIs ist deutlich höher. \\n\\n  * Zentrale Weiterentwicklung — neue Features wie der Content-Typ thinking oder verbesserte Tool-Unterstützung werden einmal hinzugefügt und sind automatisch für alle verfügbar. \\n\\n  * Die Bibliothek wurde zur Grundlage für die Herausbildung von Standards für KI-Interfaces im Ökosystem.\\n\"\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Was als Nächstes kommt{#further}\n\n\n          Nun zu den Plänen. Wir haben mehrere Richtungen identifiziert: \n\n            * Performance-Verbesserungen durch Virtualisierung für sehr große Chat-Historien. \n\n            * Erweiterung der Basisszenarien für neue Fähigkeiten von KI-Agenten, die sich aktiv weiterentwickeln. \n\n            * Hinzufügen von Utilities, um das Mapping der Daten populärer KI-Modelle auf unser Chat-Datenmodell zu vereinfachen. \n\n          Zusätzlich werden wir die Dokumentation und Beispiele ausbauen. Und\n          natürlich die Community weiterentwickeln — wir möchten, dass die\n          Bibliothek nicht nur intern, sondern auch für externe Entwickler\n          nützlich ist.\n      - type: blog-yfm-block\n        column: left\n        resetPaddings: true\n        text: >\n\n          ## Wie man AIKit ausprobieren kann{#try}\n\n\n          Schaut im [Bibliotheksbereich\n          ](https://gravity-ui.com/libraries/aikit){target=\"_blank\"}\n          auf unserer Website vorbei. Wenn ihr euren eigenen KI-Assistenten\n          baut, ein schnelles und vorhersehbares Chat-Interface wollt und bereits\n          Gravity UI verwendet (oder es ausprobieren möchtet), werft einen Blick\n          ins README und in die Beispiele. Und wir sind auch dankbar für Feedback\n          — erstellt Issues, schickt PRs und sagt uns, was ihr für eure\n          Szenarien noch braucht!\n\n\n          Wenn Ihnen unser Projekt gefällt, freuen wir uns über ⭐️ in\n          [AIKit](https://github.com/gravity-ui/aikit){target=\"_blank\"} und\n          [UIKit](https://github.com/gravity-ui/uikit){target=\"_blank\"}!\n  - type: blog-layout-block\n    resetPaddings: true\n    fullWidth: false\n    children:\n      - type: blog-meta-block\n        column: left\n        resetPaddings: true\n  - type: blog-suggest-block\n    resetPaddings: true\n",
  "title": "",
  "noIndex": false,
  "shareTitle": null,
  "shareDescription": null,
  "shareImage": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageLocaleId": null,
  "author": "timofeyevvv",
  "metaDescription": null,
  "keywords": [],
  "shareGenTitle": null,
  "canonicalLink": null,
  "sharingType": "custom",
  "sharingTheme": "light",
  "comment": "initial en",
  "shareImageUrl": "https://storage.yandexcloud.net/gravity-landing-static/blog/aikit/aikit-bg-cover.png",
  "pageRegionId": 117,
  "summary": null,
  "versionId": 268,
  "service": null,
  "solution": null,
  "locales": [
    {
      "id": 116,
      "pageId": 108,
      "locale": "ru",
      "createdAt": "2026-01-27T13:47:58.059Z",
      "updatedAt": "2026-01-27T13:47:58.118Z",
      "publishedVersionId": null,
      "lastVersionId": 263
    },
    {
      "id": 117,
      "pageId": 108,
      "locale": "en",
      "createdAt": "2026-01-27T13:47:58.121Z",
      "updatedAt": "2026-01-27T13:47:58.138Z",
      "publishedVersionId": null,
      "lastVersionId": 264
    }
  ],
  "pageRegions": [
    {
      "regionCode": "ru-ru",
      "publishedVersionId": null
    },
    {
      "regionCode": "en",
      "publishedVersionId": 268
    }
  ],
  "searchCategory": {
    "id": 7,
    "slug": "blog",
    "title": "Blog",
    "url": "/blog"
  },
  "voiceovers": []
}